---
layout: posts
title: AsicBoost-比特币挖矿加速方案
date: 2019-02-24 01:31:11

tags:
- Bitcoin
- Asicboost

category:
- Bitcoin
---

## AsicBoost - 比特币挖矿加速方案

2018年做了很多的区块链方面的研究，包括比特币Self-Mined, Asicboost,POS算法的作弊逻辑。虽然谈不上是个大牛，也算是小有见解。今年自己慢慢整理出来，也算是给自己成长的一个交代。

### 1.介绍
AsicBoost 是一种提升大约比特币 20% 挖矿效率的优化方案。应为是纯算法优化因此适用于所有的挖矿硬件和芯片。AsicBoost 方案包括了2部分，一部分是对SHA 256的算法优化，一部分是对于挖矿软件的预计算部分的处理优化。

在详细的了解Asicboost之前，我们先来了解下什么是SHA256，以及比特币的挖矿处理逻辑。


### 2.SHA256介绍

SHA256, 哈希算法，又称为散列函数，是将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。

为了方便理解，大家可以想一下较熟悉的WinRAR压缩软件，无轮是只有一个原始文件，还是好几个原始文件，都可以压缩成一个RAR文件。当任何一个原始文件有任何变动时，重新压缩生成的这个RAR文件就会发生变动，而不再是之前的文件。

而哈希算法有点类似，但其处理的对象不是文件，而是字串。将任意长度原始字串“压缩”成一个字串即Hash字串。原始字串任何一点点微小的变化都会引起Hash的变化。与RAR的不同之处是，通过Hash结果是不可以“解压”还原成原始字串的。

哈希算法有很多很多种，典型的哈希算法有MD2、MD4、MD5 、 SHA-1、SHA-2、SHA-256、SHA-512、SHA-3、RIPEMD-160和SCRYPT算法（莱特币和狗狗币使用）等等。在比特币中大量采用的是SHA256算法，在从公钥生成币地址时还另外用过RIPEMD160算法，其它地方用到Hash时一般就是用SHA256算法。其特点如下图所示将任何字串转变生成256位随机的0或1。
![image](https://i.loli.net/2019/02/24/5c71856803713.png)

### 3.比特币挖矿算法

挖矿到底在做什么是较好理解的，就是通过不断地改变原始数据，来不断地求算SHA256算法下的Hash值，当满足一定条件时成功。 

##### 3.1满足什么条件算是成功？ 

看一个最近的出块实例:
```
Height     : 564,270
Block Hash : 0000000000000000000674a05c77c2911ad42c94bc4170ac90f0c89ca8c92734
```
前20个都是零，另外后面的数也要小于一定的数，那么才满足条件。而这些哈希值结果是随机的，能做的这么规律，只能是不断地更换原文内容不断地进行尝试，在大量的随机结果中来筛选满足出块条件的。难度并非固定的，根据全网算力挖块的情况，每挖出来2016个区块（约两周时间2016/6/24=14days）就调整一次难度。若挖完2016区块所用的时间短于两周，那就提高难度；而若长于两周，那就降低难度。

##### 3.2原始数据有什么内容？ 

并非对整个区块内容取Hash值，而是仅仅只对80字节大小的区块头，进行SHA256算法。这80字节具体分为六个部分。

![image](https://i.loli.net/2019/02/24/5c7185669900c.png)

1)版本号Version：4字节，进行投票时变动

按目前的BIP9升级规范，版本号是用于投票区块自己支持的分叉升级方案，如若支持SW可版本号为0x20000002具体可看下面这个文章：

[谈谈软分叉升级规范BIP8-后矿工时代的软分叉方式](https://www.8btc.com/article/359000)

2)上一个区块Hash：32字节，有新区块时变动

这是将区块串成区块链的关键，表示这个区块是在哪个区块的基础之上进行挖矿而挖到的。当比特全网出现合法的新区块后，要及时替换上新区块的Hash，否则就算挖出来也可能被孤立。

3)交易树根MerkleRoot：32字节，交易变时变动

本应该是所有交易都进行Hash的，但是计算量太大，于是将所有交易用Merkle Root Hash的方法，将所有交易Hash合并成一个32字节的Hash数据。它能代表所有交易，任何交易的任何细小变动都会引起MerkleRoot的变动。这个后面还有更多讨论和图。

4)时间戳TimeStamp：4字节，当前时间变动

最好写当前时间，但不是很严格，允许有一定的时间偏差，但不能偏差太大，偏差太大会被区块孤立的。因为不严格，有时下个区块比它的上个区块的时间戳时间还早，这是有可能的，但真实的诞生时间当然是先有上个区块，才会有下个区块。

5)当前难度值Bits：4字节，每两周左右变一次

由全网算力决定，每2016个区块重新调整，调整算法固定，就是说在调整时，大家都可以根据历史数据自己计算出来，而不是由谁指定。怎么用四个字节表示难度呢？有点类似于天文数字的科学计数法，第一个字节V1代表右移的位数，用剩下三字节V3表示具体的有效数据。
```
F(nBits)=V3 * 2^(8*(V1-3) )
```
6)随机数Nonce：4字节，随时可变

这个是给矿工挖矿时自己调整用的，以便能找到合适的值让区块头的Hash结果能满足难度需求。这个参数估计中本聪有点失误，设计小了，仅仅4字节，CPU挖矿时代够用，但显卡GPU时代，就有点不够用了，几秒的时间就能全部的Nonce都全试了一次了。不过可以微调上面的时间戳TimeStamp，调一次就可以再挖几秒，勉强够用。然而进入专业矿机矿池时代，Nonce就远远不够用了，由于各字段一般都有较明确有固定含义不能轻易动，于是转向32字节的交易树根MerkleRoot。



##### 3.3矿池为矿工提供的挖矿服务

收集比特交易是矿池上完成的，矿池需要运行全节点，而矿工却不需要。如下图蓝线指示，矿池会由待打包的交易生成那些黑点，然后时常发给矿工。另外构造一个基本coinbase交易，也发给矿工。理论上矿池给矿工的coinbase交易内容能维持较长时间不变动。但SW隔离严证实施后，每当有交易顺序或交易内容调整时，都需要变动coinbase。还有就是矿池要提供除了MerklerRoot和Nonce之外的区块头数据。

##### 3.4矿工需要做什么？ 
矿工收到从矿池发过来的信息后:

第一步是计算红点，完善coinbase交易一般是加个随机数即可完善好，然后对coinbase交易进行SHA256的Hash计算。

第二步是计算绿点，将coinbase的结果，再依次和下图中的黑点逐一合并得出上一层的Hash，最终得到最上面的交易树根MerklerRoot。

第三步是计算区块头Hash，有了MerklerRoot后，结合矿池提供的区块头数据，再加个随机变动的Nonce就可以形成完整区块头，用其计算Hash。当Nonce完全遍历一遍和足够变动时间戳后，正常一般是回到第一步更换一个随机数来重新完善coinbase交易，进而第二步中MerklerRoot值最终将不一样。而ASICBoost可能是调换交易顺序而更新MerklerRoot。

第四步是提交成功的Share计算结果，并非要满足全网的难度般，只要满足矿池设的挖矿难度就可以提交了，一般提交给矿池自己的矿工ID和任务ID，coinbase的随机数和区块头的时间戳TimeStamp及随机数Nonce。

矿池在收到后及时进行验证，若满足则记一份功劳贡献，同时看看是否满足全网的难度要求，若满足则广播发布出去，从而挖到新块，且按记录的功劳Share数量分配给各矿工应有的币量。

![image](https://i.loli.net/2019/02/24/5c718567c4a75.png)

### 4.Asicboost优化

根据目前了解，简单说，其就是利用了SHA256算法的内部计算规则，先64字节一组，然后再4个字节一个组。而ASICBoost专利，应该就是用交换交易位置的方式，不必修改coinbase，来快速得到很多相同的末尾4字节的MerklerRoot，从而硬件可加速优化计算区块头两次SHA256的哈希值，即SHA256( SHA256( BlockHeader ))的速度。

![image](https://i.loli.net/2019/02/24/5c718567c54d9.png)

在计算这个区块头的SHA256时，我们需要先用固定的填充位补齐为128字节，之后SHA256会64字节一组去处理，可以简单认为是 F ( F（SHA256规范的初始值，前半部分）, 后半部分）。F又需要对这64字节先按4字节一组拆分，进行64轮计算。结合上图，我们不难发现，Merkle Root的前28个字节和后4个字节被分开了，在修改Nonce过程中，前半部分是不变的，而后半部分的前12个字节也是不变的。因此目前几乎所有的芯片都已经做了这两个优化，即前半部分的处理结果（getwork中的midstate）和后半部分的前3轮结果（midstate3）。**这样的优化效果是 (61/64+1)/3 = 65.1%，提升了34.9%。**
 

Merkle Root在图上显得很尴尬，如果中本聪设计的时候Version变成第三个字段该多好（就是说把Version放在MerkleRoot的后面）。这样后半段的前4个字节就固定了，如果我们对于时间戳要求不那么高，前12个字节可以完全固定下来了。对于芯片来说可以节省更多的计算，也可以去掉对应的一些电路。ASICBoost将这个脑洞往实践推了一步：我们去构建一组后4个字节相同的Merkle Root。

这样问题就变成能不能高效找到后缀一样的Merkle Root？效率提升有多大？ASICBoost的白皮书提到有很高效的方法，并且给出了一张表：

![image](https://i.loli.net/2019/02/24/5c718566f39bf.png)

ASICBoost白皮书的Merkle Root碰撞数量对效率影响ASICBoost白皮书的Merkle Root碰撞数量对效率影响。（表格的意思是若找到五个相同后4字节的Merkle Root那么效率能提升20%）
这里问题的本质是一个32位的哈希碰撞，根据“生日悖论”，找到一组碰撞需要的尝试次数其实并不多，我们只需要77000次就有50%概率找到两个后缀相同的Merkle Root。当然对于一台矿机来说，仅仅2个是远远不够的，如果是矿场的话应该需要配备专门的硬件去产生足够的任务。尝试新的Merkle Root通常有两种方法：

方法一：修改Coinbase交易。这个方法似乎最简单而且隐蔽，但是白皮书认为不够高效；

方法二：交换任意交易的顺序。白皮书只举例了方法2，其他方法并未给出。注意无论是1和2，新的Merkle Root并不需要从下而上全部计算。


#### 5.总结

看到这里，你大概就了解了什么是AsicBoost, 是简化了比特币挖矿SHA256的计算量，来提高效率的。
关于Asicboost在专利争议上还有一段故事，你可以搜索阅读下Asicboost 专利的爱恨情仇。

