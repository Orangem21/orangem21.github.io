[{"title":"Polyjuice 介绍2: 你喜欢的样子我都有","url":"http://orangem.io/2019/09/20/Polyjuice-介绍2-你喜欢的样子我都有/","content":"","categories":["Nervos"],"tags":["Bitcoin","Nervos"]},{"title":"Polyjuice 介绍1: 关公战秦琼","url":"http://orangem.io/2019/09/16/Polyjuice-介绍1-关公战秦琼/","content":"<p><img src=\"https://i.loli.net/2019/09/16/b4ajfvXK5xSnu92.jpg\" alt></p>\n<h2 id=\"Polyjuice-是什么？\"><a href=\"#Polyjuice-是什么？\" class=\"headerlink\" title=\"Polyjuice 是什么？\"></a>Polyjuice 是什么？</h2><p>按照Github里的描述:</p>\n<blockquote>\n<p>Polyjuice is a layer 2 solution that provides a Web3 compatible interface on top of Nervos CKB. The design goal here is 95%+ compatible with existing Ethereum solution, so that your Solidity smart contracts and tools for Ethereum could work directly on top of Nervos CKB.</p>\n</blockquote>\n<p>简单来说，Polyjuice 就是一整套实验性质的基于 CKB 的 Layer2 框架，近乎完整地兼容了 Ethereum 生态，你可以在上面直接部署 Solidity 合约，甚至可以使用 Web3.js。</p>\n<p>当然，与原生的 Ethereum 还是有区别的:</p>\n<ol>\n<li>在 Polyjuice 上，每个人都需要为自己的状态存储付费；</li>\n<li>可以体验到支持热升级而无需硬分叉的 EVM；</li>\n<li>不必忍受 Ethereum 状态爆炸或是交易拥堵的困扰；</li>\n</ol>\n<h2 id=\"关公战秦琼\"><a href=\"#关公战秦琼\" class=\"headerlink\" title=\"关公战秦琼\"></a>关公战秦琼</h2><p>是的，刚开始尝试理解 Ployjuice 的时候我也是一样，对这两条链是如何结合到一起的也是一脸懵逼。ETH 怎么就能成为 CKB 的 Layer2 了？ </p>\n<p>根据以前的理解，CKB 和 ETH 两条链从代币模型到合约完全不相同，CKB 是 UTXO 模型并且每个用户都需要为自己的存储付费；Ethereum 是 Account 模型，用户的存储不需要付费。怎么想两条链都不可能兼容到一起好吧？脑海里满是<strong>关公战秦琼</strong>的画面。 </p>\n<p><img src=\"https://i.loli.net/2019/09/16/PhIQbCKsYWt9rEm.jpg\" alt></p>\n<h2 id=\"Polyjuice-的配方\"><a href=\"#Polyjuice-的配方\" class=\"headerlink\" title=\"Polyjuice 的配方\"></a>Polyjuice 的配方</h2><p>通读了一遍代码之后，我开始理解了。接下来，将尝试用我自己的理解给你讲讲 Polyjuice 到底是如何实现的。能力不高水平有限，如有错误欢迎砍脸….</p>\n<p><em>那么，问题来了，关公战秦琼一共分几步？</em></p>\n<h3 id=\"第一步：打电话叫他俩过来\"><a href=\"#第一步：打电话叫他俩过来\" class=\"headerlink\" title=\"第一步：打电话叫他俩过来\"></a>第一步：打电话叫他俩过来</h3><p>在运行 Polyjuice 网络之前，需要部署几个 <a href=\"https://github.com/nervosnetwork/polyjuice/tree/master/c\" target=\"_blank\" rel=\"noopener\">Scirpt</a>（关于 Script 的更多资料可以参考 Xuejie 的 <a href=\"https://xuejie.space/\" target=\"_blank\" rel=\"noopener\">Introduction to CKB Script Programming</a>）。其中包含了 Ethereum 的私钥解锁代码，sha3 算法，以及合约的解锁代码。他们统统按照CKB的方式，写成了<code>Scripts</code>形式。</p>\n<p>以私钥解锁 Lock Script 为例，参数就变成了 ETH 的公钥，而不是 CKB 的公钥，你需要用 ETH 私钥来解锁啦，你的 CKB 私钥没有权限解锁哦。</p>\n<p>Polyjuice 通过<code>get_live_cell</code>来获取 CKB 全网哪些 Cells 是使用 Ethereum 特定的 hash 的 Lock Script, 就知道全网有多少个 Cells 是以 Ethereum 的形式存在的。</p>\n<p>你可以这么理解，当一个 Cell 的 <code>Lock Script</code> 改写成我们指定的 Ethereum 形式的 <code>Lock Script</code>, Polyjuice 就认为这个 Cell 是以 Ethereum 形式存在的 Cell，只有用 ETH 私钥才能做解锁操作。而这个 Cells 里面的 CKB 就通过<strong>代码中预先设定好的比例</strong>，被认为是一定数量的 ETH。</p>\n<p>Polyjuice 获取到全网的<code>Etheruem Cells</code>之后，就可以按照 EThereum 的方式存储到本地节点。这样，所有节点都可以共享一个 ETH 全网状态。</p>\n<p>Polyjuice 通过本地节点的服务，对外提供 Web3 的接口，完美的兼容了 Web3。</p>\n<h3 id=\"第二步：打一架打一架\"><a href=\"#第二步：打一架打一架\" class=\"headerlink\" title=\"第二步：打一架打一架\"></a>第二步：打一架打一架</h3><p>原生 ETH 的转账之后是 Account 模型下的数据加减，但是对 Polyjuice 来说，实现逻辑是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一笔交易（A-&gt;B):</span><br><span class=\"line\"> 对使用者来说: 是 A 的以太坊地址发送到 B 的以太坊地址；</span><br><span class=\"line\"> 对 Polyjuice 来说: 是能用 A 的以太坊私钥解锁的 Cells，转变成了能用 B 的以太坊私钥解锁的 Cells.</span><br></pre></td></tr></table></figure>\n<p>【此处应该有图】</p>\n<p>这样，就可以完美实现基于 CKB 的 Ethereum 转账，对 Web3 用户来说，使用体验上和原生的 Ethereum 几乎毫无差别。</p>\n<p><em>【此处应该吹一波 CKB 的可插拔密码学原语.(找 Ryan 领钱，每贴5毛)】</em></p>\n<h3 id=\"第三步：各回各家\"><a href=\"#第三步：各回各家\" class=\"headerlink\" title=\"第三步：各回各家\"></a>第三步：各回各家</h3><p>想一下: CKB 的原生 Cells 只需要更换 Scripts 就能变成 ETH，完全无痛。那么反过来，可以把这些 ETH 再次转回 CKB 吗？ </p>\n<p>答案是当然可以。你只需要用你的以太坊私钥解锁这个定制 Cells, 然后替换回默认的 Scripts,你就可以换回你的 CKB，不多不少，你的 CKB 还在这里等着你，只是你之前创造的 ETH 不再存在了。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>呐，以上是 Polyjuice 的 Ethereum 的基本逻辑。是不是感觉少了点什么？ 有点意犹未尽的样子。</p>\n<p>别着急呐，下一篇我们会讲 Polyjuice 的精华部分: 与 EVM 结合，来实现 Ethereum On CKB 的合约模型。</p>\n<p>敬请期待（欢迎打钱）</p>\n","categories":["Nervos"],"tags":["Bitcoin","Nervos"]},{"title":"CKB脚本编程简介[3]: 自定义代币","url":"http://orangem.io/2019/09/09/CKB脚本编程简介-3-自定义代币/","content":"<p>CKB的 Cell 模型和VM支持许多新的用例。然而，这并不意味着我们需要抛弃现有的。如今区块链中的一个常见用途是令牌发行者发布具有特殊目的/意义的新令牌。在以太坊中，我们称之为ERC20令牌，让我们看看我们如何在CKB中构建类似的概念。为了与ERC20区分，在CKB中的令牌我们称之为 <code>user defined token</code> , 简称UDT。</p>\n<p>本文使用CKB v0.20.0版本来演示，具体来说，我在每个项目中使用以下提交的版本:</p>\n<ul>\n<li><a href=\"https://github.com/nervosnetwork/ckb\" target=\"_blank\" rel=\"noopener\">ckb</a>: 472252ac5333b2b19ea3ec50d54e68b627bf6ac5</li>\n<li><a href=\"https://github.com/nervosnetwork/ckb-duktape\" target=\"_blank\" rel=\"noopener\">ckb-duktape</a>: 55849c20b43a212120e0df7ad5d64b2c70ea51ac</li>\n<li><a href=\"https://github.com/nervosnetwork/ckb-sdk-ruby\" target=\"_blank\" rel=\"noopener\">ckb-sdk-ruby</a>: 1c2a3c3f925e47e421f9e3c07164ececf3b6b9f6</li>\n</ul>\n<h1 id=\"数据模型\"><a href=\"#数据模型\" class=\"headerlink\" title=\"数据模型\"></a>数据模型</h1><p>与以太坊为每个合约账户提供了独特的存储空间不同，CKB是在多个 Cell 之间传递数据。Cell 的 Lock Sript 和 Type Sript 会告知 Cell 属于哪个帐户，以及如何与 Cell 进行交互。其结果是，与ERC20将所有令牌用户的余额存储在ERC20合约的存储空间中不同，在CKB中，我们需要一种新的设计来存储UDT用户的余额。</p>\n<p>当然，我们可以构造一个特殊的 Cell 来保存所有UDT用户的余额。这个解决方案看起来很像以太坊的ERC20设计。但是出现了几个问题：</p>\n<ul>\n<li>令牌发行者必须提供存储空间以保存所有用户的余额。随着用户数量的增长，存储空间也将增长，这在CKB的经济模型中，不是一个高效的设计。</li>\n<li>考虑到更新CKB中的 Cell 实际上是在销毁旧 Cell 并重新生成新 Cell ，因此保存所有余额的单个 Cell 会产生瓶颈：需要更新UDT余额的每个操作都必须更新唯一的 Cell, 使用过程中将会产生冲突。</li>\n</ul>\n<p>虽然有一些解决方案可以缓解甚至解决上述问题，但我们开始质疑这里的基本设计：将所有UDT保存在一个地方真的有意义吗？一旦转账，UDT应该真的属于接受者，为什么余额仍然保持在中心化的地方？</p>\n<p>这引出了我们提出的设计：</p>\n<ol>\n<li>一个特殊的 Type Script 表示此 Cell 存储UDT。</li>\n<li>Cell 数据的前4个字节包含当前 Cell 中的UDT数量。</li>\n</ol>\n<p>这种设计有几个含义：</p>\n<ul>\n<li>UDT Cell 的存储成本始终是恒定的，与存储在 Cell 中的UDT数量无关。</li>\n<li>用户可以将 Cell 中的全部或部分UDT转账给其他人。</li>\n<li>实际上，可能有许多 Cell 包含相同数量的UDT。</li>\n<li>用于保护UDT的 Lock Script 与UDT本身分离。</li>\n</ul>\n<p>每个令牌用户将其UDT保存在自己的 Cell 中。他们负责为UDT提供存储空间，并确保他们自己的令牌是安全的。这样UDT就可以真正属于每个UDT用户。</p>\n<p>这里还有一个问题：如果令牌存储在属于每个用户的众多 Cell 中而不是统一存储，我们如何确保令牌确实由令牌发行者创建？如果有人自己伪造代币怎么办？在以太坊中，这可能是一个问题，但正如我们将在本文中看到的，CKB中的 Type Script 可以防止所有这些攻击，确保您的令牌是安全的。</p>\n<h1 id=\"编写-UDT-脚本\"><a href=\"#编写-UDT-脚本\" class=\"headerlink\" title=\"编写 UDT 脚本\"></a>编写 UDT 脚本</h1><p>鉴于上述设计，最小UDT Type Script 应该遵守以下规则：</p>\n<ul>\n<li>在UDT交易交易中，输出 Cell 中的UDT总和应等于输入 Cell 中UDT的总和。</li>\n<li>只有令牌发行者可以在初始令牌创建过程中生成新令牌。</li>\n</ul>\n<p>这可能听起来有点雄心勃勃，但我们会看到，通过 Type Script 和一些CKB独特的设计模式，一切都可以搞定：P</p>\n<p>为简单起见，我们将在纯JavaScript中编写UDT脚本，然而C的版本可能有助于节省 Cells ，但是功能将相同。</p>\n<p>首先，我们需要遍历所有输入 Cell 并收集UDT的总和：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff --git a/udt.js b/udt.js</span><br><span class=\"line\">index e69de29..4a20bd0 100644</span><br><span class=\"line\">--- a/udt.js</span><br><span class=\"line\">+++ b/udt.js</span><br><span class=\"line\">@@ -0,0 +1,17 @@</span><br><span class=\"line\">+var input_index = 0;</span><br><span class=\"line\">+var input_coins = 0;</span><br><span class=\"line\">+var buffer = new ArrayBuffer(4);</span><br><span class=\"line\">+var ret = CKB.CODE.INDEX_OUT_OF_BOUND;</span><br><span class=\"line\">+</span><br><span class=\"line\">+while (true) &#123;</span><br><span class=\"line\">+  ret = CKB.raw_load_cell_data(buffer, 0, input_index, CKB.SOURCE.GROUP_INPUT);</span><br><span class=\"line\">+  if (ret === CKB.CODE.INDEX_OUT_OF_BOUND) &#123;</span><br><span class=\"line\">+    break;</span><br><span class=\"line\">+  &#125;</span><br><span class=\"line\">+  if (ret !== 4) &#123;</span><br><span class=\"line\">+    throw &quot;Invalid input cell!&quot;;</span><br><span class=\"line\">+  &#125;</span><br><span class=\"line\">+  var view = new DataView(buffer);</span><br><span class=\"line\">+  input_coins += view.getUint32(0, true);</span><br><span class=\"line\">+  input_index += 1;</span><br><span class=\"line\">+&#125;</span><br></pre></td></tr></table></figure>\n<p>正如前一篇文章中所解释的，CKB要求我们使用循环来迭代同一组中的所有输入 Cell 并获取数据。在C中我们将使用<code>ckb_load_cell_data</code>，它被包装到JS函数<code>CKB.raw_load_cell_data</code>中。正如ArrayBuffer所示，我们只对单元数据的前4个字节感兴趣，因为这4个字节将包含UDT的数量。</p>\n<p>注意，这里我们对<code>input_coins</code>执行一个简单的add操作，这非常危险。我们这样做只是为了简单起见。在生产环境中，您应该检查该值是否将保持在32位整数值中。如果需要，应使用更高精度的数字类型。</p>\n<p>同样，我们可以获取输出的UDT的总和并进行比较：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff --git a/udt.js b/udt.js</span><br><span class=\"line\">index 4a20bd0..e02b993 100644</span><br><span class=\"line\">--- a/udt.js</span><br><span class=\"line\">+++ b/udt.js</span><br><span class=\"line\">@@ -15,3 +15,23 @@ while (true) &#123;</span><br><span class=\"line\">   input_coins += view.getUint32(0);</span><br><span class=\"line\">   input_index += 1;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">+</span><br><span class=\"line\">+var output_index = 0;</span><br><span class=\"line\">+var output_coins = 0;</span><br><span class=\"line\">+</span><br><span class=\"line\">+while (true) &#123;</span><br><span class=\"line\">+  ret = CKB.raw_load_cell_data(buffer, 0, output_index, CKB.SOURCE.GROUP_OUTPUT);</span><br><span class=\"line\">+  if (ret === CKB.CODE.INDEX_OUT_OF_BOUND) &#123;</span><br><span class=\"line\">+    break;</span><br><span class=\"line\">+  &#125;</span><br><span class=\"line\">+  if (ret !== 4) &#123;</span><br><span class=\"line\">+    throw &quot;Invalid output cell!&quot;;</span><br><span class=\"line\">+  &#125;</span><br><span class=\"line\">+  var view = new DataView(buffer);</span><br><span class=\"line\">+  output_coins += view.getUint32(0, true);</span><br><span class=\"line\">+  output_index += 1;</span><br><span class=\"line\">+&#125;</span><br><span class=\"line\">+</span><br><span class=\"line\">+if (input_coins !== output_coins) &#123;</span><br><span class=\"line\">+  throw &quot;Input coins do not equal output coins!&quot;;</span><br><span class=\"line\">+&#125;</span><br></pre></td></tr></table></figure>\n<p>这几乎是验证第一条规则所需的全部内容：输出 Cell 中UDT的总和应等于输入 Cell 中UDT的总和。换句话说，现在使用这种 Type Script ，没有人能够伪造新的令牌。这不是很棒吗？</p>\n<p>但有一个问题：当我们说没有人能够伪造新的代币时，我们真的意味着没有人，包括代币发行人！这可不太好，我们需要添加一个例外，因此令牌发行者可以先创建令牌，但之后没有人能够这样做。有没有办法做到这一点？</p>\n<p>当然有！但答案就像一个谜语，所以请仔细阅读本段：Type Script 由2部分组成：表示实际代码的代码哈希，以及 Type Script 使用的参数。具有不同参数的2种 Type Script 将被视为2种不同 Type Script 。这里的技巧是允许令牌发行者创建一个具有新 Type Script 的 Cell ，没有人能够再次创建，所以如果我们在参数部分放置一些不能再包含的东西，那么问题就被解决了~</p>\n<p>现在想想这个问题：什么东西不能包含在区块链中两次？交易输入中的OutPoint！我们第一次将OutPoint作为交易输入包含在内时，引用的 Cell 将被消耗，如果有人稍后再次包含它，则会产生双花错误，这正是我们使用区块链的原因。</p>\n<p>我们现在有答案了！ CKB中最小UDT的 Type Script 完整验证流程如下：</p>\n<ol>\n<li>首先收集输入 Cell 中所有UDT的总和以及输出 Cell 中所有UDT的总和，如果它们相等，则 Type Script 将以成功状态退出。</li>\n<li>检查 Type Script 的第一个参数是否与当前交易中的第一个OutPoint匹配，如果它们匹配，则以成功状态退出。</li>\n<li>否则以失败状态退出。</li>\n</ol>\n<p>您可以看出：步骤1对应于正常的UDT交易，而步骤2对应于初始令牌创建过程。</p>\n<p>这就是我们所说的CKB独特的设计模式：通过使用输入OutPoint作为 Script 参数，我们可以创建一个无法再伪造的独特 Script：</p>\n<ol>\n<li>如果攻击者试图使用相同的参数，则 Script 将验证交易中的第一个输入OutPoint与参数不匹配，从而使交易无效;</li>\n<li>如果攻击者试图使用相同的参数并填充参数作为第一个输入OutPoint，它将创建一个双花错误，也会使交易无效;</li>\n<li>如果攻击者试图使用不同的参数，CKB将识别出不同的参数导致不同的 Type Script，从而生成不同的UDT。</li>\n</ol>\n<p>这种简单而强大的模式确保UDT保持安全，同时享受它们可以在许多不同单元之间自由传输的好处。据我们所知，这种模式在其他许多声称灵活或可编程的区块链中是不可能实现的。</p>\n<p>现在我们终于可以完成我们UDT脚本了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff --git a/contract.js b/contract.js</span><br><span class=\"line\">deleted file mode 100644</span><br><span class=\"line\">index e69de29..0000000</span><br><span class=\"line\">diff --git a/udt.js b/udt.js</span><br><span class=\"line\">index e02b993..cd443bf 100644</span><br><span class=\"line\">--- a/udt.js</span><br><span class=\"line\">+++ b/udt.js</span><br><span class=\"line\">@@ -1,3 +1,7 @@</span><br><span class=\"line\">+if (CKB.ARGV.length !== 1) &#123;</span><br><span class=\"line\">+  throw &quot;Requires only one argument!&quot;;</span><br><span class=\"line\">+&#125;</span><br><span class=\"line\">+</span><br><span class=\"line\"> var input_index = 0;</span><br><span class=\"line\"> var input_coins = 0;</span><br><span class=\"line\"> var buffer = new ArrayBuffer(4);</span><br><span class=\"line\">@@ -33,5 +37,17 @@ while (true) &#123;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> if (input_coins !== output_coins) &#123;</span><br><span class=\"line\">-  throw &quot;Input coins do not equal output coins!&quot;;</span><br><span class=\"line\">+  if (!((input_index === 0) &amp;&amp; (output_index === 1))) &#123;</span><br><span class=\"line\">+    throw &quot;Invalid token issuing mode!&quot;;</span><br><span class=\"line\">+  &#125;</span><br><span class=\"line\">+  var first_input = CKB.load_input(0, 0, CKB.SOURCE.INPUT);</span><br><span class=\"line\">+  if (typeof first_input === &quot;number&quot;) &#123;</span><br><span class=\"line\">+    throw &quot;Cannot fetch the first input&quot;;</span><br><span class=\"line\">+  &#125;</span><br><span class=\"line\">+  var hex_input = Array.prototype.map.call(</span><br><span class=\"line\">+    new Uint8Array(first_input),</span><br><span class=\"line\">+    function(x) &#123; return (&apos;00&apos; + x.toString(16)).slice(-2); &#125;).join(&apos;&apos;);</span><br><span class=\"line\">+  if (CKB.ARGV[0] != hex_input) &#123;</span><br><span class=\"line\">+    throw &quot;Invalid creation argument!&quot;;</span><br><span class=\"line\">+  &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>就是这样，一共有53行代码或1372字节，我们就在CKB中完成了一个最小的UDT Type Script 。注意我在这里甚至没有使用压缩工具，使用任何不错的JS压缩工具，我们应该能够获得更紧凑的 Type Script 。当然了，这是一个可用于生产环境的 Type Script ，但它足以显示一个简单的 Type Script 足以处理CKB中的重要任务。</p>\n<h1 id=\"部署到CKB网络\"><a href=\"#部署到CKB网络\" class=\"headerlink\" title=\"部署到CKB网络\"></a>部署到CKB网络</h1><p>我不喜欢<a href=\"https://hacks.mozilla.org/2019/09/debugging-webassembly-outside-of-the-browser/\" target=\"_blank\" rel=\"noopener\">其他一些组织</a> 只向你展示一个视频和一个充满挑战性的帖子其中隐藏了他们如何做到这一点以及伴随的问题。我相信如果没有真正的代码和使用它的步骤，它将是无趣的。以下是如何在CKB上使用上述UDT脚本：</p>\n<p>以防万一，这里是没有diff格式的完整UDT脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat udt.js</span><br><span class=\"line\">if (CKB.ARGV.length !== 1) &#123;</span><br><span class=\"line\">  throw &quot;Requires only one argument!&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var input_index = 0;</span><br><span class=\"line\">var input_coins = 0;</span><br><span class=\"line\">var buffer = new ArrayBuffer(4);</span><br><span class=\"line\">var ret = CKB.CODE.INDEX_OUT_OF_BOUND;</span><br><span class=\"line\">while (true) &#123;</span><br><span class=\"line\">  ret = CKB.raw_load_cell_data(buffer, 0, input_index, CKB.SOURCE.GROUP_INPUT);</span><br><span class=\"line\">  if (ret === CKB.CODE.INDEX_OUT_OF_BOUND) &#123;</span><br><span class=\"line\">    break;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (ret !== 4) &#123;</span><br><span class=\"line\">    throw &quot;Invalid input cell!&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var view = new DataView(buffer);</span><br><span class=\"line\">  input_coins += view.getUint32(0, true);</span><br><span class=\"line\">  input_index += 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var output_index = 0;</span><br><span class=\"line\">var output_coins = 0;</span><br><span class=\"line\">while (true) &#123;</span><br><span class=\"line\">  ret = CKB.raw_load_cell_data(buffer, 0, output_index, CKB.SOURCE.GROUP_OUTPUT);</span><br><span class=\"line\">  if (ret === CKB.CODE.INDEX_OUT_OF_BOUND) &#123;</span><br><span class=\"line\">    break;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (ret !== 4) &#123;</span><br><span class=\"line\">    throw &quot;Invalid output cell!&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var view = new DataView(buffer);</span><br><span class=\"line\">  output_coins += view.getUint32(0, true);</span><br><span class=\"line\">  output_index += 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (input_coins !== output_coins) &#123;</span><br><span class=\"line\">  if (!((input_index === 0) &amp;&amp; (output_index === 1))) &#123;</span><br><span class=\"line\">    throw &quot;Invalid token issuing mode!&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var first_input = CKB.load_input(0, 0, CKB.SOURCE.INPUT);</span><br><span class=\"line\">  if (typeof first_input === &quot;number&quot;) &#123;</span><br><span class=\"line\">    throw &quot;Cannot fetch the first input&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var hex_input = Array.prototype.map.call(</span><br><span class=\"line\">    new Uint8Array(first_input),</span><br><span class=\"line\">    function(x) &#123; return (&apos;00&apos; + x.toString(16)).slice(-2); &#125;).join(&apos;&apos;);</span><br><span class=\"line\">  if (CKB.ARGV[0] != hex_input) &#123;</span><br><span class=\"line\">    throw &quot;Invalid creation argument!&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了能在CKB上运行JavaScript，让我们首先在CKB上部署duktape：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pry(main)&gt; data = File.read(&quot;../ckb-duktape/build/duktape&quot;)</span><br><span class=\"line\">pry(main)&gt; duktape_tx_hash = wallet.send_capacity(wallet.address, CKB::Utils.byte_to_shannon(300000), CKB::Utils.bin_to_hex(duktape_data))</span><br><span class=\"line\">pry(main)&gt; duktape_data_hash = CKB::Blake2b.hexdigest(duktape_data)</span><br><span class=\"line\">pry(main)&gt; duktape_out_point = CKB::Types::CellDep.new(out_point: CKB::Types::OutPoint.new(tx_hash: duktape_tx_hash, index: 0))</span><br></pre></td></tr></table></figure>\n<p>首先，让我们创建一个包含1000000令牌的UDT：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pry(main)&gt; tx = wallet.generate_tx(wallet.address, CKB::Utils.byte_to_shannon(20000))</span><br><span class=\"line\">pry(main)&gt; tx.cell_deps.push(duktape_out_point.dup)</span><br><span class=\"line\">pry(main)&gt; arg = CKB::Utils.bin_to_hex(CKB::Serializers::InputSerializer.new(tx.inputs[0]).serialize)</span><br><span class=\"line\">pry(main)&gt; duktape_udt_script = CKB::Types::Script.new(code_hash: duktape_data_hash, args: [CKB::Utils.bin_to_hex(File.read(&quot;udt.js&quot;)), arg])</span><br><span class=\"line\">pry(main)&gt; tx.outputs[0].type = duktape_udt_script</span><br><span class=\"line\">pry(main)&gt; tx.outputs_data[0] = CKB::Utils.bin_to_hex([1000000].pack(&quot;L&lt;&quot;))</span><br><span class=\"line\">pry(main)&gt; tx.witnesses[0].data.clear</span><br><span class=\"line\">pry(main)&gt; signed_tx = tx.sign(wallet.key, api.compute_transaction_hash(tx))</span><br><span class=\"line\">pry(main)&gt; root_udt_tx_hash = api.send_transaction(signed_tx)</span><br></pre></td></tr></table></figure>\n<p>如果我们再次尝试提交相同的交易，则双花将阻止我们伪造相同的令牌：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pry(main)&gt; api.send_transaction(signed_tx)</span><br><span class=\"line\">CKB::RPCError: jsonrpc error: &#123;:code=&gt;-3, :message=&gt;&quot;UnresolvableTransaction(Dead(OutPoint(0x0b607e9599f23a8140d428bd24880e5079de1f0ee931618b2f84decf2600383601000000)))&quot;&#125;</span><br></pre></td></tr></table></figure>\n<p>无论我们如何尝试，我们都无法创建另一个想要伪造相同UDT令牌的 Cell 。</p>\n<p>现在我们可以尝试将UDT转移到另一个帐户。首先让我们尝试创建一个输出UDT比输入UDT更多的UDT交易：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pry(main)&gt; udt_out_point = CKB::Types::OutPoint.new(tx_hash: root_udt_tx_hash, index: 0)</span><br><span class=\"line\">pry(main)&gt; tx = wallet.generate_tx(wallet2.address, CKB::Utils.byte_to_shannon(20000))</span><br><span class=\"line\">pry(main)&gt; tx.cell_deps.push(duktape_out_point.dup)</span><br><span class=\"line\">pry(main)&gt; tx.witnesses[0].data.clear</span><br><span class=\"line\">pry(main)&gt; tx.witnesses.push(CKB::Types::Witness.new(data: []))</span><br><span class=\"line\">pry(main)&gt; tx.outputs[0].type = duktape_udt_script</span><br><span class=\"line\">pry(main)&gt; tx.outputs_data[0] = CKB::Utils.bin_to_hex([1000000].pack(&quot;L&lt;&quot;))</span><br><span class=\"line\">pry(main)&gt; tx.inputs.push(CKB::Types::Input.new(previous_output: udt_out_point, since: &quot;0&quot;))</span><br><span class=\"line\">pry(main)&gt; tx.outputs.push(tx.outputs[1].dup)</span><br><span class=\"line\">pry(main)&gt; tx.outputs[2].capacity = CKB::Utils::byte_to_shannon(20000)</span><br><span class=\"line\">pry(main)&gt; tx.outputs[2].type = duktape_udt_script</span><br><span class=\"line\">pry(main)&gt; tx.outputs_data.push(CKB::Utils.bin_to_hex([1000000].pack(&quot;L&lt;&quot;)))</span><br><span class=\"line\">pry(main)&gt; signed_tx = tx.sign(wallet.key, api.compute_transaction_hash(tx))</span><br><span class=\"line\">pry(main)&gt; api.send_transaction(signed_tx)</span><br><span class=\"line\">CKB::RPCError: jsonrpc error: &#123;:code=&gt;-3, :message=&gt;&quot;InvalidTx(ScriptFailure(ValidationFailure(-2)))&quot;&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里，我们尝试发送另一个用户1000000 UDT，同时为发送者本身保留1000000 UDT，当然这应该会触发错误，因为我们正在尝试伪造更多令牌。但稍作修改，我们可以证明，如果您遵守总和验证规则，UDT转移交易是有效的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pry(main)&gt; tx.outputs_data[0] = CKB::Utils.bin_to_hex([900000].pack(&quot;L&lt;&quot;))</span><br><span class=\"line\">pry(main)&gt; tx.outputs_data[2] = CKB::Utils.bin_to_hex([100000].pack(&quot;L&lt;&quot;))</span><br><span class=\"line\">pry(main)&gt; signed_tx = tx.sign(wallet.key, api.compute_transaction_hash(tx))</span><br><span class=\"line\">pry(main)&gt; api.send_transaction(signed_tx)</span><br></pre></td></tr></table></figure>\n<h1 id=\"灵活规则\"><a href=\"#灵活规则\" class=\"headerlink\" title=\"灵活规则\"></a>灵活规则</h1><p>这里显示的UDT脚本仅作为示例，实际上，dapps可能更复杂并且需要更多功能。您还可以根据需要为UDT脚本添加更多功能，其中一些示例包括：</p>\n<ul>\n<li>这里我们严格确保输出UDT的总和等于输入UDT的总和，但在某些情况下，仅仅确保输出UDT的总和不超过输入UDT的总和就足够了。换句话说，当不需要时，用户可以选择为空间 烧毁 UDT。</li>\n<li>上述UDT脚本不允许在初始创建过程后发出更多令牌，但可能存在另一种类型的UDT，允许来自令牌发行者的增发。这当然也可以在CKB上运行，解决这个任务的实际方法，留在这里作为练习:)</li>\n<li>在这里，我们将脚本限制为仅在初始令牌创建过程中创建一个 Cell ，也可以创建多个单元格以在初始令牌创建过程中分散使用。</li>\n<li>虽然我们只在这里介绍ERC20，但ERC721也应该是完全可能的。</li>\n</ul>\n<p>请注意这些只是一些例子，使用CKB脚本的实际方法是没有边界的。我们非常高兴看到CKB dapp开发者创造出让我们感到惊讶的使用CKB脚本的有趣用法。</p>\n","categories":["Nervos"],"tags":["Bitcoin","Nervos"]},{"title":"CKB脚本编程简介[2]: 脚本基础","url":"http://orangem.io/2019/07/24/CKB脚本编程简介-2-脚本基础/","content":"<p>上一篇我们介绍了当前 CKB 的验证模型。这一篇会更加有趣一点，我们要向大家展示如何将脚本代码真正部署到 CKB 网络上去。我希望在你看完本文后，你可以有能力自行去探索 CKB 的世界并按照你自己的意愿去编写新的脚本代码。</p>\n<p>需要注意的是，尽管我相信目前的 CKB 的编程模型已经相对稳定了，但是开发仍在进行中，因此未来还可能会有一些变化。我将尽力确保本文始终处于最新的状态，但是如果在过程到任何疑惑，本文以<a href=\"https://github.com/nervosnetwork/ckb/commit/80b51a9851b5d535625c5d144e1accd38c32876b\" target=\"_blank\" rel=\"noopener\">此版本下的 CKB</a> 作为依据。</p>\n<p>警告：这是一篇很长的文章，因为我想为下周更有趣的话题提供充足的内容。所以如果你没有充足的时间，你不必马上完成它。我在试着把它分成几个独立的不凡，这样你就可以一次尝试一个。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>在继续之前，我们先来区分两个术语：脚本（script）和脚本代码（script code）</p>\n<p>在本文以及整个系列文章内，我们将区分脚本和脚本代码。脚本代码实际上是指你编写和编译并在 CKB 上运行的程序。而脚本，实际上是指 CKB 中使用的脚本数据结构，它会比脚本代码稍微多一点点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pub struct Script &#123;</span><br><span class=\"line\">    pub args: Vec&lt;Bytes&gt;,</span><br><span class=\"line\">    pub code_hash: H256,</span><br><span class=\"line\">    pub hash_type: ScriptHashType,</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>我们目前可以先忽略<code>hash_type</code>，之后的文章再来解释什么是<code>hash_type</code>以及它有什么有趣的用法。在这篇文章的后面，我们会说明<code>code_hash</code>实际上是用来标识脚本代码的，所以目前我们可以只把它当成脚本代码。那脚本还包括什么呢?脚本还包括<code>args</code>这个部分，它是用来区分脚本和脚本代码的。<code>args</code>在这里可以用来给一个 CKB 脚本提供额外的参数，比如：虽然大家可能都会使用相同的默认的 lock script code，但是每个人可能都有自己的 pubkey hash，<code>args</code> 就是用来保存 pubkey hash 的位置。这样，每一个CKB 的用户都可以拥有不同的 lock script ，但是却可以共用同样的 lock script code。</p>\n<p>请注意，在大多数情况下，脚本和脚本代码是可以互换使用的，但是如果你在某些地方感到了困惑，那么你可能有必要考虑一下两者间的区别。</p>\n<h2 id=\"一个最小的-CKB-脚本代码\"><a href=\"#一个最小的-CKB-脚本代码\" class=\"headerlink\" title=\"一个最小的 CKB 脚本代码\"></a>一个最小的 CKB 脚本代码</h2><p>你可能之前就已经听所过了，CKB （编者注：此处指的应该是 CKB VM）是基于开源的 RISC-V 指令集编写的。但这到底意味着什么呢？用我自己的话来说，这意味着我们（在某种程度上）在 CKB 中嵌入了一台真正的微型计算机，而不是一台虚拟机。一台真正的计算机的好处是，你可以用任何语言编写任何你想写的逻辑。在这里，我们展示的前面几个例子将会用 C语言编写，以保持简单性（我是说工具链中的简单性，而不是<a href=\"http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html\" target=\"_blank\" rel=\"noopener\">语言</a>），之后我们还会切换到基于 JavaScript 的脚本代码，并希望在本系列中展示更多的语言。记住，在 CKB 上有无限的可能！</p>\n<p>正如我们提到的，CKB VM 更像是一台真正的微型计算机。CKB 的代码脚本看起来也更像是我们在电脑上跑的一个常见的 Unix 风格的可执行程序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main(int argc, char* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当你的代码通过 C 编译器编译时，它将成为可以在 CKB 上运行的脚本代码。换句话说，CKB 只是采用了普通的旧式 Unix 风格的可执行程序(但使用的是 RISC-V 体系结构，而不是流行的 x86 体系结构)，并在虚拟机环境中运行它。如果程序的返回代码是 0 ，我们认为脚本成功了，所有非零的返回代码都将被视为失败脚本。</p>\n<p>在上面的例子中，我们展示了一个总是成功的脚本代码。因为返回代码总是 0。但是请不要使用这个作为您的 lock script code ，否则您的 token 可能会被任何人拿走。</p>\n<p>但是显然上面的例子并不有趣，这里我们从一个有趣的想法开始:我个人不是很喜欢胡萝卜。我知道胡萝卜从营养的角度来看是很好的，但我还是想要避免它的味道。如果现在我想设定一个规则，比如我想让我在 CKB 上的 Cell 里面都没有以<code>carrot</code>开头的数据?让我们编写一个脚本代码来实现这一点。</p>\n<p>为了确保没有一个 cell 在 cell data<br>中包含<code>carrot</code>，我们首先需要一种方法来读取脚本中的 cell data。CKB 提供了<code>syscalls</code>来帮助解决这个问题。</p>\n<p>为了确保 CKB 脚本的安全性，每个脚本都必须在与运行 CKB 的主计算机完全分离的隔离环境中运行。这样它就不能访问它不需要的数据，比如你的私钥或密码。然而，要使得脚本有用，必须有特定的数据要访问，比如脚本保护的 cell 或脚本验证的事务。CKB 提供了<code>syscalls</code>来确保这一点，<code>syscalls</code>是在 RISC-V 的标准中定义的，它们提供了访问环境中某些资源的方法。在正常情况下，这里的环境指的是操作系统，但是在 CKB VM 中，环境指的是实际的 CKB 进程。使用<code>syscalls</code>， CKB脚本可以访问包含自身的整个事务，包括输入（inputs）、输出（outpus）、见证（witnesses）和 deps。</p>\n<p>好消息是，我们已经将<code>syscalls</code>封装在了一个易于使用的头文件中，非常欢迎您在这里<a href=\"https://github.com/nervosnetwork/ckb-system-scripts/blob/66d7da8ec72dffaa7e9c55904833951eca2422a9/c/ckb_syscalls.h\" target=\"_blank\" rel=\"noopener\">查看这个文件</a>，了解如何实现<code>syscalls</code>。最重要的是，您可以只获取这个头文件并使用包装函数来创建您想要的系统调用。</p>\n<p>现在有了<code>syscalls</code>，我们可以从禁止使用<code>carrot</code>的脚本开始:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;memory.h&gt;</span><br><span class=\"line\">#include &quot;ckb_syscalls.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[]) &#123;</span><br><span class=\"line\">  int ret;</span><br><span class=\"line\">  size_t index = 0;</span><br><span class=\"line\">  volatile uint64_t len = 0; /* (1) */</span><br><span class=\"line\">  unsigned char buffer[6];</span><br><span class=\"line\"></span><br><span class=\"line\">  while (1) &#123;</span><br><span class=\"line\">    len = 6;</span><br><span class=\"line\">    memset(buffer, 0, 6);</span><br><span class=\"line\">    ret = ckb_load_cell_by_field(buffer, &amp;len, 0, index, CKB_SOURCE_OUTPUT,</span><br><span class=\"line\">                                 CKB_CELL_FIELD_DATA); /* (2) */</span><br><span class=\"line\">    if (ret == CKB_INDEX_OUT_OF_BOUND) &#123;               /* (3) */</span><br><span class=\"line\">      break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (memcmp(buffer, &quot;carrot&quot;, 6) == 0) &#123;</span><br><span class=\"line\">      return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    index++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下几点需要解释一下：</p>\n<ol>\n<li><p>由于 C 语言的怪癖，<code>len</code>字段需要标记为<code>volatile</code>。我们会同时使用它作为输入和输出参数，CKB VM 只能在它还保存在内存中时，才可以把它设置输出参数。而<code>volatile</code>可以确保 C 编译器将它保存为基于 RISC-V 内存的变量。</p>\n</li>\n<li><p>在使用<code>syscall</code>时，我们需要提供以下功能：一个缓冲区来保存<code>syscall</code>提供的数据；一个<code>len</code>字段，来表示系统调用返回的缓冲区长度和可用数据长度；一个输入数据缓冲区中的偏移量，以及几个我们在交易中需要获取的确切字段的参数。详情请参阅我们的<a href=\"https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0009-vm-syscalls/0009-vm-syscalls.md\" target=\"_blank\" rel=\"noopener\">RFC</a>。</p>\n</li>\n<li><p>为了保证最大的灵活性，CKB 使用系统调用的返回值来表示数据抓取状态:0 (or <code>CKB_SUCCESS</code>) 意味着成功，1 (or <code>CKB_INDEX_OUT_OF_BOUND</code>) 意味着您已经通过一种方式获取了所有的索引，2 (or<code>CKB_ITEM_MISSING</code>) 意味着不存在一个实体，比如从一个不包含该 type 脚本的 cell 中获取该 type 的脚本。</p>\n</li>\n</ol>\n<p>概况一下，这个脚本将循环遍历交易中的所有输出 cells，加载每个 cell data 的前6个字节，并测试这些字节是否和<code>carrot</code>匹配。如果找到匹配，脚本将返回<code>-1</code>，表示错误状态；如果没有找到匹配，脚本将返回<code>0</code>退出，表示执行成功。</p>\n<p>为了执行该循环，该脚本将保存一个<code>index</code>变量，在每次循环迭代中，它将试图让 syscall 获取 cell 中目前采用的<code>index</code>值，如果 syscall 返回<code>CKB_INDEX_OUT_OF_BOUND</code>，这意味着脚本已经遍历所有的 cell，之后会退出循环；否则，循环将继续，每测试 cell data 一次，<code>index</code>变量就会递增一次。</p>\n<p>这是第一个有用的 CKB 脚本代码！在下一节中，我们将看到我们是如何将其部署到 CKB 中并运行它的。</p>\n<h2 id=\"将脚本部署到-CKB-上\"><a href=\"#将脚本部署到-CKB-上\" class=\"headerlink\" title=\"将脚本部署到 CKB 上\"></a>将脚本部署到 CKB 上</h2><p>首先，我们需要编译上面写的关于胡萝卜的源代码。由于 GCC 已经提供了 RISC-V 的支持，您当然可以使用官方的 GCC 来创建脚本代码。或者你也可以使用我们准备的 <a href=\"https://hub.docker.com/r/nervos/ckb-riscv-gnu-toolchain\" target=\"_blank\" rel=\"noopener\">docker 镜像</a>来避免编译 GCC 的麻烦:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ls</span><br><span class=\"line\">carrot.c  ckb_consts.h  ckb_syscalls.h</span><br><span class=\"line\">$ sudo docker run --rm -it -v `pwd`:/code nervos/ckb-riscv-gnu-toolchain:xenial bash</span><br><span class=\"line\">root@dc2c0c209dcd:/# cd /code</span><br><span class=\"line\">root@dc2c0c209dcd:/code# riscv64-unknown-elf-gcc -Os carrot.c -o carrot</span><br><span class=\"line\">root@dc2c0c209dcd:/code# exit</span><br><span class=\"line\">exit</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">carrot*  carrot.c  ckb_consts.h  ckb_syscalls.h</span><br></pre></td></tr></table></figure>\n<p>就是这样，CKB 可以直接使用 GCC 编译的可执行文件作为链上的脚本，无需进一步处理。我们现在可以在链上部署它了。注意，我将使用 CKB 的 Ruby SDK，因为我曾经是一名 Ruby 程序员，当然 Ruby 对我来说是最自然的(但不一定是最好的)。如何设置请参考<a href=\"https://github.com/nervosnetwork/ckb-sdk-ruby/blob/develop/README.md\" target=\"_blank\" rel=\"noopener\">官方 Readme 文件</a>。</p>\n<p>要将脚本部署到 CKB，我们只需创建一个新的 cell，把脚本代码设为 cell data 部分:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pry(main)&gt; data = File.read(&quot;carrot&quot;)</span><br><span class=\"line\">pry(main)&gt; data.bytesize</span><br><span class=\"line\">=&gt; 6864</span><br><span class=\"line\">pry(main)&gt; carrot_tx_hash = wallet.send_capacity(wallet.address, CKB::Utils.byte_to_shannon(8000), CKB::Utils.bin_to_hex(data))</span><br></pre></td></tr></table></figure>\n<p>在这里，我首先要通过向自己发送 token 来创建一个容量足够的新的 cell。现在我们可以创建包含胡萝卜脚本代码的脚本:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pry(main)&gt; carrot_data_hash = CKB::Blake2b.hexdigest(data)</span><br><span class=\"line\">pry(main)&gt; carrot_type_script = CKB::Types::Script.new(code_hash: carrot_data_hash, args: [])</span><br></pre></td></tr></table></figure>\n<p>回忆一下脚本数据结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pub struct Script &#123;</span><br><span class=\"line\">    pub args: Vec&lt;Bytes&gt;,</span><br><span class=\"line\">    pub code_hash: H256,</span><br><span class=\"line\">    pub hash_type: ScriptHashType,</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，我们没有直接将脚本代码嵌入到脚本数据结构中，而是只包含了代码的哈希，这是实际脚本二进制代码的 Blake2b 哈希。由于胡萝卜脚本不使用参数，我们可以对<code>args</code>部分使用空数组。</p>\n<p>注意，这里仍然忽略了 <code>hash_type</code>，我们将在后面的文章中通过另一种方式讨论指定代码哈希。现在，让我们尽量保持简单。</p>\n<p>要运行胡萝卜脚本，我们需要创建一个新的交易，并将胡萝卜 type 脚本设置为其中一个输出 cell 的 type 脚本:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pry(main)&gt; tx = wallet.generate_tx(wallet2.address, CKB::Utils.byte_to_shannon(200))</span><br><span class=\"line\">pry(main)&gt; tx.outputs[0].instance_variable_set(:@type, carrot_type_script.dup)</span><br></pre></td></tr></table></figure>\n<p>我们还需要进行一个步骤：为了让 CKB 可以找到胡萝卜脚本，我们需要在一笔交易的 deps 中引用包含胡萝卜脚本的 cell：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pry(main)&gt; carrot_out_point = CKB::Types::OutPoint.new(cell: CKB::Types::CellOutPoint.new(tx_hash: carrot_tx_hash, index: 0))</span><br><span class=\"line\">pry(main)&gt; tx.deps.push(carrot_out_point.dup)</span><br></pre></td></tr></table></figure>\n<p>现在我们准备签名并发送交易：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[44] pry(main)&gt; tx.witnesses[0].data.clear</span><br><span class=\"line\">[46] pry(main)&gt; tx = tx.sign(wallet.key, api.compute_transaction_hash(tx))</span><br><span class=\"line\">[19] pry(main)&gt; api.send_transaction(tx)</span><br><span class=\"line\">=&gt; &quot;0xd7b0fea7c1527cde27cc4e7a2e055e494690a384db14cc35cd2e51ec6f078163&quot;</span><br></pre></td></tr></table></figure>\n<p>由于该交易的 cell 中没有任何一个的 cell data 包含<code>carrot</code>，因此 type 脚本将验证成功。现在让我们尝试一个不同的交易，它确实含有一个以<code>carrot</code>开头的 cell：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pry(main)&gt; tx2 = wallet.generate_tx(wallet2.address, CKB::Utils.byte_to_shannon(200))</span><br><span class=\"line\">pry(main)&gt; tx2.deps.push(carrot_out_point.dup)</span><br><span class=\"line\">pry(main)&gt; tx2.outputs[0].instance_variable_set(:@type, carrot_type_script.dup)</span><br><span class=\"line\">pry(main)&gt; tx2.outputs[0].instance_variable_set(:@data, CKB::Utils.bin_to_hex(&quot;carrot123&quot;))</span><br><span class=\"line\">pry(main)&gt; tx2.witnesses[0].data.clear</span><br><span class=\"line\">pry(main)&gt; tx2 = tx2.sign(wallet.key, api.compute_transaction_hash(tx2))</span><br><span class=\"line\">pry(main)&gt; api.send_transaction(tx2)</span><br><span class=\"line\">CKB::RPCError: jsonrpc error: &#123;:code=&gt;-3, :message=&gt;&quot;InvalidTx(ScriptFailure(ValidationFailure(-1)))&quot;&#125;</span><br><span class=\"line\">from /home/ubuntu/code/ckb-sdk-ruby/lib/ckb/rpc.rb:164:in `rpc_request&apos;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，我们的胡萝卜脚本拒绝了一笔生成的 cell 中包含胡萝卜的交易。现在我可以使用这个脚本来确保所有的 cell 中都不含胡萝卜!</p>\n<p>所以，总结一下，部署和运行一个 type 脚本的脚本，我们需要做的是:</p>\n<ol>\n<li>将脚本编译为 RISC-V 可执行的二进制文件  </li>\n<li>在 cell 的 data 部分部署二进制文件</li>\n<li>创建一个 type 脚本数据结构，使用二进制文件的 blake2b 散列作为<code>code hash</code>，补齐<code>args</code>部分中脚本代码的需要的参数</li>\n<li>用生成的 cell 中设置的 type 脚本创建一个新的交易</li>\n<li>将包含脚本代码的 cell 的 outpoint 写入到一笔交易的 deps 中去</li>\n</ol>\n<p>这就是你所有需要的！如果您的脚本遇到任何问题，您需要检查这些要点。</p>\n<p>虽然在这里我们只讨论了 type 脚本，但是 lock 脚本的工作方式完全相同。您惟一需要记住的是，当您使用特定的 lock 脚本创建 cell 时，lock 脚本不会在这里运行，它只在您使用 cell 时运行。因此， type 脚本可以用于构造创建 cell 时运行的逻辑，而 lock 脚本用于构造销毁 cell 时运行的逻辑。考虑到这一点，请确保您的 lock 脚本是正确的，否则您可能会在以下场景中丢失 token:</p>\n<blockquote>\n<p>您的 lock 脚本有一个其他人也可以解锁您的 cell 的 bug。<br>您的 lock 脚本有一个 bug，任何人(包括您)都无法解锁您的 cell。</p>\n</blockquote>\n<p>在这里我们可以提供的一个技巧是，始终将您的脚本作为一个 type 脚本附加到你交易的一个 output cell 中去进行测试，这样，发生错误时，您可以立即知道，并且您的 token 可以始终保持安全。</p>\n<h2 id=\"分析默认-lock-脚本代码\"><a href=\"#分析默认-lock-脚本代码\" class=\"headerlink\" title=\"分析默认 lock 脚本代码\"></a>分析默认 lock 脚本代码</h2><p>根据已经掌握的知识，让我们看看 CKB 中包含的默认的 lock 脚本代码。 为了避免混淆，我们正在查看 lock 脚本代码在 <a href=\"https://github.com/nervosnetwork/ckb-system-scripts/blob/66e2b3fc4fa3e80235e4b4f94a16e81352a812f7/c/secp256k1_blake160_sighash_all.c\" target=\"_blank\" rel=\"noopener\">这个commit</a>。</p>\n<p>默认的 lock 脚本代码将循环遍历与自身具有相同 lock 脚本的所有的 input cell，并执行以下步骤:</p>\n<ul>\n<li><p>它通过提供的 syscall 获取当前的交易 hash</p>\n</li>\n<li><p>它获取相应的 witness 数据作为当前输入</p>\n</li>\n<li><p>对于默认 lock 脚本，假设 witness 中的第一个参数包含由 cell 所有者签名的可恢复签名，其余参数是用户提供的可选参数</p>\n</li>\n<li><p>默认的 lock 脚本运行 由交易 hash 链接的二进制程序的 blake2b hash， 还有所有用户提供的参数(如果存在的话)</p>\n</li>\n<li><p>将 blake2b hash 结果用作 secp256k1 签名验证的消息部分。注意，witness 数据结构中的第一个参数提供了实际的签名。</p>\n</li>\n<li><p>如果签名验证失败，脚本退出并返回错误码。否则它将继续下一个迭代。</p>\n</li>\n</ul>\n<p>注意，我们在前面讨论了脚本和脚本代码之间的区别。每一个不同的公钥 hash 都会产生不同的 lock 脚本，因此，如果一个交易的输入 cell 具有相同的默认 lock 脚本代码，但具有不同的公钥 hash(因此具有不同的 lock 脚本)，将执行默认 lock 脚本代码的多个实例，每个实例都有一组共享相同 lock 脚本的 cell。</p>\n<p>现在我们可以遍历默认 lock 脚本代码的不同部分:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (argc != 2) &#123;</span><br><span class=\"line\">  return ERROR_WRONG_NUMBER_OF_ARGUMENTS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">secp256k1_context context;</span><br><span class=\"line\">if (secp256k1_context_initialize(&amp;context, SECP256K1_CONTEXT_VERIFY) == 0) &#123;</span><br><span class=\"line\">  return ERROR_SECP_INITIALIZE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">len = BLAKE2B_BLOCK_SIZE;</span><br><span class=\"line\">ret = ckb_load_tx_hash(tx_hash, &amp;len, 0);</span><br><span class=\"line\">if (ret != CKB_SUCCESS) &#123;</span><br><span class=\"line\">  return ERROR_SYSCALL;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当参数包含在 <code>Script</code>数据结构的 <code>args</code>部分， 它们通过 Unix 传统的<code>arc</code>/<code>argv</code>方式发送给实际运行的脚本程序。<br>为了进一步保持约定，我们在<code>argv[0]</code> 处插入一个伪参数，所以 第一个包含的参数从<code>argv[1]</code>开始。<br>在默认 lock 脚本代码的情况下，它接受一个参数，即从所有者的私钥生成的公钥 hash。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ret = ckb_load_input_by_field(NULL, &amp;len, 0, index, CKB_SOURCE_GROUP_INPUT,</span><br><span class=\"line\">                             CKB_INPUT_FIELD_SINCE);</span><br><span class=\"line\">if (ret == CKB_INDEX_OUT_OF_BOUND) &#123;</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (ret != CKB_SUCCESS) &#123;</span><br><span class=\"line\">  return ERROR_SYSCALL;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用与胡萝卜这个例子相同的技术，我们检查是否有更多的输入 cell 要测试。与之前的例子有两个不同:</p>\n<ul>\n<li><p>如果我们只想知道一个 cell 是否存在并且不需要任何数据，我们只需要传入<code>NULL</code> 作为数据缓冲区，一个 <code>len</code> 变量的值是 0。<br>通过这种方式，syscall 将跳过数据填充，只提供可用的数据长度和正确的返回码用于处理。</p>\n</li>\n<li><p>在这个 carrot 的例子中，我们循环遍历交易中的所有输入， 但这里我们只关心具有相同 lock 脚本的输入cell。 CKB将具有相同锁定(或类型)脚本的<code>cell</code>命名为<code>group</code>。 我们可以使用 <code>CKB_SOURCE_GROUP_INPUT</code> 代替 <code>CKB_SOURCE_INPUT</code>， 来表示只计算同一组中的 cell，举个例子，即具有与当前 cell 相同的 lock 脚本的 cells。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">len = WITNESS_SIZE;</span><br><span class=\"line\">ret = ckb_load_witness(witness, &amp;len, 0, index, CKB_SOURCE_GROUP_INPUT);</span><br><span class=\"line\">if (ret != CKB_SUCCESS) &#123;</span><br><span class=\"line\">  return ERROR_SYSCALL;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (len &gt; WITNESS_SIZE) &#123;</span><br><span class=\"line\">  return ERROR_WITNESS_TOO_LONG;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">if (!(witness_table = ns(Witness_as_root(witness)))) &#123;</span><br><span class=\"line\">  return ERROR_ENCODING;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">args = ns(Witness_data(witness_table));</span><br><span class=\"line\">if (ns(Bytes_vec_len(args)) &lt; 1) &#123;</span><br><span class=\"line\">  return ERROR_WRONG_NUMBER_OF_ARGUMENTS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续沿着这个路径，我们正在加载当前输入的 witness。 对应的 witness 和输入具有相同的索引。<br>现在 CKB 在 syscalls 中使用<code>flatbuffer</code>作为序列化格式，所以如果你很好奇，<a href=\"https://github.com/dvidelabs/flatcc\" target=\"_blank\" rel=\"noopener\">flatcc的文档</a>是你最好的朋友。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* Load signature */</span><br><span class=\"line\">len = TEMP_SIZE;</span><br><span class=\"line\">ret = extract_bytes(ns(Bytes_vec_at(args, 0)), temp, &amp;len);</span><br><span class=\"line\">if (ret != CKB_SUCCESS) &#123;</span><br><span class=\"line\">  return ERROR_ENCODING;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* The 65th byte is recid according to contract spec.*/</span><br><span class=\"line\">recid = temp[RECID_INDEX];</span><br><span class=\"line\">/* Recover pubkey */</span><br><span class=\"line\">secp256k1_ecdsa_recoverable_signature signature;</span><br><span class=\"line\">if (secp256k1_ecdsa_recoverable_signature_parse_compact(&amp;context, &amp;signature, temp, recid) == 0) &#123;</span><br><span class=\"line\">  return ERROR_SECP_PARSE_SIGNATURE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">blake2b_state blake2b_ctx;</span><br><span class=\"line\">blake2b_init(&amp;blake2b_ctx, BLAKE2B_BLOCK_SIZE);</span><br><span class=\"line\">blake2b_update(&amp;blake2b_ctx, tx_hash, BLAKE2B_BLOCK_SIZE);</span><br><span class=\"line\">for (size_t i = 1; i &lt; ns(Bytes_vec_len(args)); i++) &#123;</span><br><span class=\"line\">  len = TEMP_SIZE;</span><br><span class=\"line\">  ret = extract_bytes(ns(Bytes_vec_at(args, i)), temp, &amp;len);</span><br><span class=\"line\">  if (ret != CKB_SUCCESS) &#123;</span><br><span class=\"line\">    return ERROR_ENCODING;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  blake2b_update(&amp;blake2b_ctx, temp, len);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">blake2b_final(&amp;blake2b_ctx, temp, BLAKE2B_BLOCK_SIZE);</span><br></pre></td></tr></table></figure>\n<p>witness 中的第一个参数是要加载的签名，而其余的参数(如果提供的话)被附加到用于 blake2b 操作的交易 hash 中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">secp256k1_pubkey pubkey;</span><br><span class=\"line\"></span><br><span class=\"line\">if (secp256k1_ecdsa_recover(&amp;context, &amp;pubkey, &amp;signature, temp) != 1) &#123;</span><br><span class=\"line\">  return ERROR_SECP_RECOVER_PUBKEY;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后使用哈希后的 blake2b 结果作为信息，进行 secp256 签名验证。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">size_t pubkey_size = PUBKEY_SIZE;</span><br><span class=\"line\">if (secp256k1_ec_pubkey_serialize(&amp;context, temp, &amp;pubkey_size, &amp;pubkey, SECP256K1_EC_COMPRESSED) != 1 ) &#123;</span><br><span class=\"line\">  return ERROR_SECP_SERIALIZE_PUBKEY;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">len = PUBKEY_SIZE;</span><br><span class=\"line\">blake2b_init(&amp;blake2b_ctx, BLAKE2B_BLOCK_SIZE);</span><br><span class=\"line\">blake2b_update(&amp;blake2b_ctx, temp, len);</span><br><span class=\"line\">blake2b_final(&amp;blake2b_ctx, temp, BLAKE2B_BLOCK_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">if (memcmp(argv[1], temp, BLAKE160_SIZE) != 0) &#123;</span><br><span class=\"line\">  return ERROR_PUBKEY_BLAKE160_HASH;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后同样重要的是，我们还需要检查可恢复签名中包含的 pubkey 确实是用于生成 lock 脚本参数中包含的 pubkey hash 的 pubkey。<br>否则，可能会有人使用另一个公钥生成的签名来窃取你的 token。</p>\n<p>简而言之，默认 lock 脚本中使用的方案与现在<a href=\"https://bitcoin.org/en/transactions-guide#p2pkh-script-validation\" target=\"_blank\" rel=\"noopener\">比特币中使用的方案</a>非常相似。</p>\n<h2 id=\"介绍-Duktape\"><a href=\"#介绍-Duktape\" class=\"headerlink\" title=\"介绍 Duktape\"></a>介绍 Duktape</h2><p>我相信你和我现在的感觉一样: 我们可以用 C 语言写合约，这很好，但是 C 语言总是让人觉得有点乏味，而且，让我们面对现实，它很危险。<br>有更好的方法吗?</p>\n<p>当然！ 我们上面提到的 CKB VM 本质上是一台微型计算机，我们可以探索很多解决方案。 我们在这里做的一件事是，使用 JavaScript 编写 CKB 脚本代码。 是的，你说对了，简单的 ES5 (是的，我知道，但这只是一个例子，你可以使用转换器) JavaScript。</p>\n<p>这怎么可能呢? 由于我们有 C 编译器,我们只需为嵌入式系统使用一个 JavaScript 实现，在我们的例子中，<a href=\"https://duktape.org/\" target=\"_blank\" rel=\"noopener\">duktape</a><br>将它从 C 编译成 RISC-V 二进制文件，把它放在链上，我们就可以在 CKB 上运行 JavaScript 了!因为我们使用的是一台真正的微型计算机，所以没有什么可以阻止我们将另一个 VM 作为 CKB 脚本嵌入到 CKB VM 中，并在 VM 路径上探索这个 VM。</p>\n<p>从这条路径展开，我们可以通过 duktape 在 CKB 上使用 JavaScript，我们也可以通过 <a href=\"https://github.com/mruby/mruby\" target=\"_blank\" rel=\"noopener\">mruby</a>在 ckb 上使用 Ruby， 我们甚至可以将比特币脚本或EVM放到链上，我们只需要编译他们的虚拟机，并把它放在链上。这确保了 CKB VM 既能帮助我们保存资产，又能构建一个多样化的生态系统。所有的语言都应该在 CKB 上被平等对待，自由应该掌握在区块链合约的开发者手中。</p>\n<p>在这个阶段，你可能想问: 是的，这是可能的，但是 VM 之上的 VM 不会很慢吗? 我相信这取决于你的例子是否很慢。我坚信，基准测试没有任何意义，除非我们将它放在具有标准硬件需求的实际用例中。 所以我们需要有时间检验这是否真的会成为一个问题。 在我看来，高级语言更可能用于 type scripts 来保护 cell 转换，在这种情况下，我怀疑它会很慢。此外，我们也在这个领域努力工作，以优化 CKB VM 和 VMs 之上的 CKB VM，使其越来越快，:P</p>\n<p>要在 CKB 上使用 duktape，首先需要将 duktape 本身编译成 RISC-V 可执行二进制文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https://github.com/nervosnetwork/ckb-duktape</span><br><span class=\"line\">$ cd ckb-duktape</span><br><span class=\"line\">$ sudo docker run --rm -it -v `pwd`:/code nervos/ckb-riscv-gnu-toolchain:xenial bash</span><br><span class=\"line\">root@0d31cad7a539:~# cd /code</span><br><span class=\"line\">root@0d31cad7a539:/code# make</span><br><span class=\"line\">riscv64-unknown-elf-gcc -Os -DCKB_NO_MMU -D__riscv_soft_float -D__riscv_float_abi_soft -Iduktape -Ic -Wall -Werror c/entry.c -c -o build/entry.o</span><br><span class=\"line\">riscv64-unknown-elf-gcc -Os -DCKB_NO_MMU -D__riscv_soft_float -D__riscv_float_abi_soft -Iduktape -Ic -Wall -Werror duktape/duktape.c -c -o build/duktape.o</span><br><span class=\"line\">riscv64-unknown-elf-gcc build/entry.o build/duktape.o -o build/duktape -lm -Wl,-static -fdata-sections -ffunction-sections -Wl,--gc-sections -Wl,-s</span><br><span class=\"line\">root@0d31cad7a539:/code# exit</span><br><span class=\"line\">exit</span><br><span class=\"line\">$ ls build/duktape</span><br><span class=\"line\">build/duktape*</span><br></pre></td></tr></table></figure>\n<p>与 carrot 示例一样，这里的第一步是在 CKB cell 中部署 duktape 脚本代码:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pry(main)&gt; data = File.read(<span class=\"string\">\"../ckb-duktape/build/duktape\"</span>)</span><br><span class=\"line\">pry(main)&gt; duktape_data.bytesize</span><br><span class=\"line\">=&gt; <span class=\"number\">269064</span></span><br><span class=\"line\">pry(main)&gt; duktape_tx_hash = wallet.send_capacity(wallet.address, CKB::Utils.byte_to_shannon(<span class=\"number\">280000</span>), CKB::Utils.bin_to_hex(duktape_data))</span><br><span class=\"line\">pry(main)&gt; duktape_data_hash = CKB::Blake2b.hexdigest(duktape_data)</span><br><span class=\"line\">pry(main)&gt; duktape_out_point = CKB::Types::OutPoint.new(<span class=\"symbol\">cell:</span> CKB::Types::CellOutPoint.new(<span class=\"symbol\">tx_hash:</span> duktape_tx_hash, <span class=\"symbol\">index:</span> <span class=\"number\">0</span>))</span><br></pre></td></tr></table></figure>\n<p>与 carrot 的例子不同，duktape 脚本代码现在需要一个参数: 要执行的 JavaScript 源代码:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pry(main)&gt; duktape_hello_type_script = CKB::Types::Script.new(<span class=\"symbol\">code_hash:</span> duktape_data_hash, <span class=\"symbol\">args:</span> [CKB::Utils.bin_to_hex(<span class=\"string\">\"CKB.debug(\\\"I'm running in JS!\\\")\"</span>)])</span><br></pre></td></tr></table></figure>\n<p>注意，使用不同的参数，你可以为不同的用例创建不同的 duktape 支持的 type script：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pry(main)&gt; duktape_hello_type_script = CKB::Types::Script.new(<span class=\"symbol\">code_hash:</span> duktape_data_hash, <span class=\"symbol\">args:</span> [CKB::Utils.bin_to_hex(<span class=\"string\">\"var a = 1;\\nvar b = a + 2;\"</span>)])</span><br></pre></td></tr></table></figure>\n<p>这反映了上面提到的脚本代码与脚本之间的差异：这里 duktape 作为提供 JavaScript 引擎的脚本代码，而不同的脚本利用 duktape 脚本代码在链上提供不同的功能。</p>\n<p>现在我们可以创建一个 cell 与 duktape 的 type script 附件:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pry(main)&gt; tx = wallet.generate_tx(wallet2.address, CKB::Utils.byte_to_shannon(<span class=\"number\">200</span>))</span><br><span class=\"line\">pry(main)&gt; tx.deps.push(duktape_out_point.dup)</span><br><span class=\"line\">pry(main)&gt; tx.outputs[<span class=\"number\">0</span>].instance_variable_set(<span class=\"symbol\">:</span>@type, duktape_hello_type_script.dup)</span><br><span class=\"line\">pry(main)&gt; tx.witnesses[<span class=\"number\">0</span>].data.clear</span><br><span class=\"line\">pry(main)&gt; tx = tx.sign(wallet.key, api.compute_transaction_hash(tx))</span><br><span class=\"line\">pry(main)&gt; api.send_transaction(tx)</span><br><span class=\"line\">=&gt; <span class=\"string\">\"0x2e4d3aab4284bc52fc6f07df66e7c8fc0e236916b8a8b8417abb2a2c60824028\"</span></span><br></pre></td></tr></table></figure>\n<p>我们可以看到脚本执行成功，如果在<code>ckb.toml</code> 文件中将 <code>ckb-script</code>日志模块的级别设置为<code>debug</code>，你可以看到以下日志:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-07-15 05:59:13.551 +00:00 http.worker8 DEBUG ckb-script  script group: c35b9fed5fc0dd6eaef5a918cd7a4e4b77ea93398bece4d4572b67a474874641 DEBUG OUTPUT: I<span class=\"string\">'m running in JS!</span></span><br></pre></td></tr></table></figure>\n<p>现在您已经成功地在 CKB 上部署了一个 JavaScript 引擎，并在 CKB 上运行基于 JavaScript 的脚本!<br>你可以在这里尝试认识的 JavaScript 代码。</p>\n<h2 id=\"一道思考题\"><a href=\"#一道思考题\" class=\"headerlink\" title=\"一道思考题\"></a>一道思考题</h2><p>现在你已经熟悉了 CKB 脚本的基础知识，下面是一个思考：<br>在本文中，您已经看到了一个 always-success 的脚本是什么样子的，但是一个 always-failure 的脚本呢?<br>一个 always-failure 脚本(和脚本代码)能有多小?</p>\n<p>提示：这不是 gcc 优化比赛，这只是一个思考。</p>\n<h2 id=\"下集预告\"><a href=\"#下集预告\" class=\"headerlink\" title=\"下集预告\"></a>下集预告</h2><p>我知道这是一个很长的帖子，我希望你已经尝试过，并成功地部署了一个脚本到 CKB。在下一篇文章中，我们将介绍一个重要的主题:如何在 CKB 定义自己的用户定义 token(UDT)。CKB 上 udt 最好的部分是，每个用户都可以将自己的 udt 存储在自己的 cell 中，这与 Ethereum 上的 ERC20 令牌不同，<br>在 Ethereum 上，每个人的 token 都必须位于 token 发起者的单个地址中。所有这些都可以通过单独使用 type script 来实现。<br>如果你感兴趣，请继续关注 :)</p>\n<p>本文作者：Xuejie<br>原文链接：<a href=\"https://xuejie.space/2019_07_13_introduction_to_ckb_script_programming_script_basics/\" target=\"_blank\" rel=\"noopener\">https://xuejie.space/2019_07_13_introduction_to_ckb_script_programming_script_basics/</a><br>本文译者：Shooter，Jason，Orange</p>\n","categories":["Nervos"],"tags":["Bitcoin","Nervos"]},{"title":"Nervos Script 初体验","url":"http://orangem.io/2019/07/09/Nervos-Script-初体验/","content":"<h1 id=\"【首杀达成】Nervos-Script-初体验\"><a href=\"#【首杀达成】Nervos-Script-初体验\" class=\"headerlink\" title=\"【首杀达成】Nervos Script 初体验\"></a>【首杀达成】Nervos Script 初体验</h1><h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p>一直很好奇 Nervos 的 Script 到底是怎么运行的，也想了解CKB的 Risc-V 的神奇之处，想自己亲手体验下，但是目前还没找到这方面的文档，我们就打算把这实践当做一个CKB的高难度的副本，来做一次开荒抢首杀的体验～</p>\n<h2 id=\"合约编写\"><a href=\"#合约编写\" class=\"headerlink\" title=\"合约编写\"></a>合约编写</h2><p>理论上，CKB底层是Risc-V，任何可以编译的语言都可以使用，这里我们使用了C来写一个简单的Demo：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (argc == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-2</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (argc == <span class=\"number\">5</span> ) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">-3</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单描述下，合约接受参数，如果参数数量 = 3 ，就返回-2，如果参数数量等于5，就返回-3，其他任意参数都可以返回0.</p>\n<p>合约使用了<code>riscv-tools</code>编译，编译之后为6.1KB，已知1CKB = 1Bytes…所以我们大概需要6100CKB 来存储这个合约…. (貌似有点大….)</p>\n<p><em>本来挖到了2个块一共3800CKB..然后发现钱不够…也再挖不出了…就默默寻求场外帮助了…丹妞赞助了1100WCKB…(如果是主网Token多好…)</em></p>\n<h2 id=\"合约部署\"><a href=\"#合约部署\" class=\"headerlink\" title=\"合约部署\"></a>合约部署</h2><p><em>有钱了做事情就有底气了…(我要打10个！)</em></p>\n<p>接下来就需要把编译好的合约部署到网络里。首先读取这个二进制文件，转成16进制，然后构造一笔交易，塞到Output 的 Data里面去，效果如下：<br><img src=\"https://i.loli.net/2019/07/09/5d240eb09d60741721.jpg\" alt></p>\n<p><a href=\"https://explorer.nervos.org/transaction/0x2928ab517396220e3c8336588bb70a445e4fc271975a3a3cf59309253e05de78\" target=\"_blank\" rel=\"noopener\">交易TX</a></p>\n<p><em>这笔交易我们构造了一个1100W的Cell空间，有钱就是NB！</em></p>\n<h2 id=\"合约调用\"><a href=\"#合约调用\" class=\"headerlink\" title=\"合约调用\"></a>合约调用</h2><p>接下来我们构造了一笔交易，将这个 Cell 空间 作为Input，分成了5个Output，也就是创建了5个新的Cell，这5个Cell的 <code>LockScript</code> 的<code>Codehash</code>都引用了上面部署的Data的<code>Hash</code>, 调用了上面Data的代码;<code>args</code>分别给了0-4个参数，来校验能不能正确解锁。</p>\n<p><a href=\"https://explorer.nervos.org/transaction/0x395fc85dc84950ee394447418405e33413e3c0700e12d6e67c98452e797b0a3f\" target=\"_blank\" rel=\"noopener\">交易TX</a></p>\n<blockquote>\n<p>知识点：VM在尝试解锁的时候，会默认帮我带一个参数进去，所以这5个Cell的参数个数分别是：1-5，所以我应该是可以解锁1，2，4个Cell的…另外….3个Cell 任何人都能解锁…他不会验证私钥的…</p>\n</blockquote>\n<h2 id=\"合约验证\"><a href=\"#合约验证\" class=\"headerlink\" title=\"合约验证\"></a>合约验证</h2><p>现在我们尝试解锁第1个Cell，把他们作为Input!</p>\n<p>当当当～成功了！入链了！</p>\n<p><a href=\"https://explorer.nervos.org/transaction/0x6a39d410a1eb50a5e6fcf2c3722c2c652df6271860545bc1b9ecc95cae0e4c76\" target=\"_blank\" rel=\"noopener\">交易TX</a></p>\n<p>接着我们尝试解锁第3个Cell～</p>\n<p>这时候报错了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: &#123;&quot;code&quot;:-3,&quot;message&quot;:&quot;InvalidTx(ScriptFailure(ValidationFailure(-3)))&quot;&#125;</span><br></pre></td></tr></table></figure>\n<p>说明解锁失败～我们的代码生效了！</p>\n<p>到此，合约调用和验证的完整流程结束撒花～～</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>最后附上吐槽和总结…</p>\n<p>这次的首杀过程中，Nervos的VM的灵活性带给我们无限的可能，我们可以更加灵活的创造，不受VM的限制。</p>\n<p>但是…这种灵活性会给安全性带来一系列的挑战，所以开发者需要更谨慎的开发，避免出现风险。</p>\n<h2 id=\"彩蛋环节\"><a href=\"#彩蛋环节\" class=\"headerlink\" title=\"彩蛋环节\"></a>彩蛋环节</h2><p>我们留了2个 Cell 未解锁，如果你能成功解锁并留言TX的话，我个人赠送1个木猿～一共2枚～</p>\n<p>一起来玩吧～</p>\n","categories":["Nervos"],"tags":["Bitcoin","Nervos"]},{"title":"CKB脚本编程简介[1]: 验证模型","url":"http://orangem.io/2019/07/07/CKB脚本编程简介-1-验证模型/","content":"<p>截至目前，CKB中的Cell验证模型或多或少已经趋于稳定，因此我将在这里开始写一系列文章来介绍CKB脚本编程。我的目标是补充在阅读白皮书后编写CKB脚本所需的所有缺失的细节实现，这样您就可以开始探索CKB呈现的这个美丽的仙境。</p>\n<p>您可能会注意到我将在CKB上运行的代码称为<code>脚本</code>，而不是<code>智能合约</code>。这是因为智能合约对我来说是一个令人困惑的术语，我在这里想用另一个词来表示CKB独特的可编程性。CKB中的脚本不一定只是我们在脚本语言中看到的脚本，例如Ruby，JS，它实际上是指在CKB VM上运行的RISC-V格式二进制文件。</p>\n<p>这第一篇文章将专门介绍CKB v0.14.0中引入的<a href=\"https://github.com/nervosnetwork/ckb/pull/913\" target=\"_blank\" rel=\"noopener\">全新验证模型</a>。这可能听起来很无聊，但我保证这是最后一篇没有实际例子的帖子 :P</p>\n<p>请注意，尽管我认为CKB的编程模型现在非常稳定，但目前仍然在进行开发，因此可能会有变化。我会尽力确保这篇文章更新，但如果有什么让你感到困惑的话，这篇文章现在正在描述CKB的这次<a href=\"https://github.com/nervosnetwork/ckb/commit/a02c675c50c5969a588fa7f6356f08861d8f5f92\" target=\"_blank\" rel=\"noopener\">提交</a>。</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>下面一张图片说明了CKB的真实交易过程：</p>\n<p><img src=\"/images/tx.svg\" alt=\"Transaction Example\"></p>\n<p>这张图中有很多内容，我们将在稍后的文章中再次回到此图。今天，我们将只关注单元数据结构中的2个实体：<code>lock</code>和<code>type</code>。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CellOutput</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> capacity: Capacity,</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> data: Bytes,</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> lock: Script,</span><br><span class=\"line\">    <span class=\"meta\">#[serde(rename = <span class=\"meta-string\">\"type\"</span>)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> type_: <span class=\"built_in\">Option</span>&lt;Script&gt;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从数据结构中我们可以看到<code>lock</code>和<code>type</code>共享相同的结构，稍后我们可以证明它们也是在同一个环境中执行的，它们之间的差异只是在几个小细节中：</p>\n<ul>\n<li><code>lock</code> 是必须的, while <code>type</code> 是可选项</li>\n<li>通常, 他们用于不同的实例</li>\n</ul>\n<p>我们首先从<code>type</code>脚本开始。</p>\n<h2 id=\"type-脚本\"><a href=\"#type-脚本\" class=\"headerlink\" title=\"type 脚本\"></a>type 脚本</h2><p>请注意，注意这里的名字只是一个幸运的意外，它与心爱的<a href=\"https://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener\">编程语言</a>无关.</p>\n<p>如果你考虑一下，CKB（或大多数基于UTXO的区块链）上的交易只会将一组Cell（或UTXO）转换为另一组Cell。有趣的是，这里的实际转换过程。这就是我们开始设计CKB验证模型的地方：我们如何构建模型以更好地验证Cell 转换？</p>\n<p>这就是<code>type</code>脚本的用武之地：<code>type</code>脚本用于验证 Cell 转换阶段的某些规则。这里的一些例子包括：</p>\n<ul>\n<li>验证UDT（用户定义的Token）余额以确保不会无效地发出新Token。</li>\n</ul>\n<h2 id=\"lock-脚本\"><a href=\"#lock-脚本\" class=\"headerlink\" title=\"lock 脚本\"></a>lock 脚本</h2><h2 id=\"运行模型\"><a href=\"#运行模型\" class=\"headerlink\" title=\"运行模型\"></a>运行模型</h2><p>现在让我们看看是什么时候执行 lock 和 type 脚本的。</p>\n<h2 id=\"回到例子\"><a href=\"#回到例子\" class=\"headerlink\" title=\"回到例子\"></a>回到例子</h2><p>这是我们之前看到的交易：</p>\n<p><img src=\"/images/tx.svg\" alt=\"Transaction Example\"></p>\n<p>在图中，执行流程如下:</p>\n<ol>\n<li><code>Lock Script 1</code> 执行一次。 </li>\n<li><code>Lock Script 2</code> 执行一次。 </li>\n<li><code>Type Script 1</code> 执行一次。 </li>\n<li><code>Type Script 2</code> 执行一次。</li>\n</ol>\n<p>在后面的文章中，我们可以看到 lock 和 type 脚本都在相同的环境中执行，并且都可以访问整个交易。如果任何一个脚本失败，整个交易就会失败。只有当所有脚本都成功时，交易才被认为是有效的。</p>\n<p>有几点值得一提:</p>\n<blockquote>\n<p>尽管有 2 个带有<code>Lock Script 1</code>的 input cell，但它只执行一次，由实际的 lock 脚本来定位具有相同 lock 脚本的所有 input cell，并验证两个签名。</p>\n</blockquote>\n<blockquote>\n<p>在这个交易中只执行 input cell 中的 lock 脚本，例如：这里不执行<code>Lock Script 3</code>。</p>\n</blockquote>\n<blockquote>\n<p>即使 input cell 和 output cell 都包含<code>Type Script 1</code>，也只执行一次。</p>\n</blockquote>\n<blockquote>\n<p>在 input 和 output cell 中都会执行 type 脚本，其中包括<code>Type Script 1</code>和<code>Type Script 2</code>。</p>\n</blockquote>\n<blockquote>\n<p>有些 cell 没有 type 脚本，在本例中我们只是省略了执行。</p>\n</blockquote>\n<h2 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h2><p>现在我们总结一下规则:</p>\n<blockquote>\n<p>在 input cell 中的 lock 脚本会被收集和解压，每个单独的 lock 脚本会被执行一次，并且只执行一次。</p>\n</blockquote>\n<blockquote>\n<p>input 和 output cell 中的 type 脚本(如果存在的话)会被收集在一起并解码，每个单独的 type 脚本都会被执行一次，并且只执行一次。</p>\n</blockquote>\n<blockquote>\n<p>任何脚本失败，则整个交易验证失败。</p>\n</blockquote>\n<h2 id=\"下期预告\"><a href=\"#下期预告\" class=\"headerlink\" title=\"下期预告\"></a>下期预告</h2><p>现在已经介绍了 cell 模型，我们将在下一篇文章中研究如何实际编写 CKB VM 脚本。将验证默认的 secp256k1 lock 脚本，来演示 CKB VM 脚本的使用周期。</p>\n","categories":["Nervos"],"tags":["Bitcoin","Nervos"]},{"title":"iPhone Xs ESIM 体验","url":"http://orangem.io/2019/03/24/iPhoneXsESIM体验/","content":"<h1 id=\"iPhone-Xs-ESIM-体验\"><a href=\"#iPhone-Xs-ESIM-体验\" class=\"headerlink\" title=\"iPhone Xs ESIM 体验\"></a>iPhone Xs ESIM 体验</h1><p>从<code>一加5</code>换到了<code>iPhone Xs</code> 之后对我来说最大的区别就是没有双卡了，因为用的是港版<code>iPhone Xs</code>所以可以使用Esim.迫于尝鲜我试用了<code>clubsim</code>的Esim服务。</p>\n<h4 id=\"注册香港手机号\"><a href=\"#注册香港手机号\" class=\"headerlink\" title=\"注册香港手机号\"></a>注册香港手机号</h4><p>中国大陆的用户可以通过微信关注<code>易博通</code>来注册一个香港的手机号码来接收短信，一年大概60元。二维码在下面，扫描我的二维码会免费送你30天体验。</p>\n<p><img src=\"https://i.loli.net/2019/03/24/5c96734674c47.jpg\" alt=\"15533609483787.jpg\"></p>\n<h4 id=\"注册ClubEsim\"><a href=\"#注册ClubEsim\" class=\"headerlink\" title=\"注册ClubEsim\"></a>注册ClubEsim</h4><p>注册<code>clubsim</code>的Esim服务很简单，目前是免费送2天漫游，可以在国内体验。<br>只需要在 <a href=\"https://www.clubsim.com.hk/clsweb/\" target=\"_blank\" rel=\"noopener\">clubsim官网</a> 使用你的香港手机号注册下就好，不需要提供其他信息。</p>\n<p>注册后会往你的邮箱发送一封带有Esim二维码的邮件，在<code>iPhone Xs</code>添加网络，扫描邮件的二维码会自动加入这张卡。</p>\n<p>好了，现在的iPhone就可以使用双卡了，和原生卡没有任何区别。<br><img src=\"https://i.loli.net/2019/03/24/5c9673468c5ca.jpg\" alt=\"15533628331064.jpg\"></p>\n<h4 id=\"使用ESIM\"><a href=\"#使用ESIM\" class=\"headerlink\" title=\"使用ESIM\"></a>使用ESIM</h4><p>添加号码以后你就可以畅想无痛翻墙的网络，网速度测试如下。</p>\n<p><img src=\"https://i.loli.net/2019/03/24/5c967346a205f.jpg\" alt=\"15533630170743.jpg\"></p>\n<h4 id=\"ESIM畅想\"><a href=\"#ESIM畅想\" class=\"headerlink\" title=\"ESIM畅想\"></a>ESIM畅想</h4><p>ESIM的体验非常棒，貌似iPhone可以几十张ESIM，相当于你手机可以差几十张卡，再也不用跑运营商的营业厅办理开卡，直接扫描二维码就可以了。我认为是非常棒的体验，期待能有一天在国内的运营商能支持，当然了这可能只是我的梦想，毕竟我的Watch到现在也没开通….</p>\n","categories":["Daily"],"tags":["Daily"]},{"title":"AsicBoost-比特币挖矿加速方案","url":"http://orangem.io/2019/02/24/AsicBoost-比特币挖矿加速方案/","content":"<h2 id=\"AsicBoost-比特币挖矿加速方案\"><a href=\"#AsicBoost-比特币挖矿加速方案\" class=\"headerlink\" title=\"AsicBoost - 比特币挖矿加速方案\"></a>AsicBoost - 比特币挖矿加速方案</h2><p>2018年做了很多的区块链方面的研究，包括比特币Self-Mined, Asicboost,POS算法的作弊逻辑。虽然谈不上是个大牛，也算是小有见解。今年自己慢慢整理出来，也算是给自己成长的一个交代。</p>\n<h3 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1.介绍\"></a>1.介绍</h3><p>AsicBoost 是一种提升大约比特币 20% 挖矿效率的优化方案。应为是纯算法优化因此适用于所有的挖矿硬件和芯片。AsicBoost 方案包括了2部分，一部分是对SHA 256的算法优化，一部分是对于挖矿软件的预计算部分的处理优化。</p>\n<p>在详细的了解Asicboost之前，我们先来了解下什么是SHA256，以及比特币的挖矿处理逻辑。</p>\n<h3 id=\"2-SHA256介绍\"><a href=\"#2-SHA256介绍\" class=\"headerlink\" title=\"2.SHA256介绍\"></a>2.SHA256介绍</h3><p>SHA256, 哈希算法，又称为散列函数，是将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。</p>\n<p>为了方便理解，大家可以想一下较熟悉的WinRAR压缩软件，无轮是只有一个原始文件，还是好几个原始文件，都可以压缩成一个RAR文件。当任何一个原始文件有任何变动时，重新压缩生成的这个RAR文件就会发生变动，而不再是之前的文件。</p>\n<p>而哈希算法有点类似，但其处理的对象不是文件，而是字串。将任意长度原始字串“压缩”成一个字串即Hash字串。原始字串任何一点点微小的变化都会引起Hash的变化。与RAR的不同之处是，通过Hash结果是不可以“解压”还原成原始字串的。</p>\n<p>哈希算法有很多很多种，典型的哈希算法有MD2、MD4、MD5 、 SHA-1、SHA-2、SHA-256、SHA-512、SHA-3、RIPEMD-160和SCRYPT算法（莱特币和狗狗币使用）等等。在比特币中大量采用的是SHA256算法，在从公钥生成币地址时还另外用过RIPEMD160算法，其它地方用到Hash时一般就是用SHA256算法。其特点如下图所示将任何字串转变生成256位随机的0或1。<br><img src=\"https://i.loli.net/2019/02/24/5c71856803713.png\" alt=\"image\"></p>\n<h3 id=\"3-比特币挖矿算法\"><a href=\"#3-比特币挖矿算法\" class=\"headerlink\" title=\"3.比特币挖矿算法\"></a>3.比特币挖矿算法</h3><p>挖矿到底在做什么是较好理解的，就是通过不断地改变原始数据，来不断地求算SHA256算法下的Hash值，当满足一定条件时成功。 </p>\n<h5 id=\"3-1满足什么条件算是成功？\"><a href=\"#3-1满足什么条件算是成功？\" class=\"headerlink\" title=\"3.1满足什么条件算是成功？\"></a>3.1满足什么条件算是成功？</h5><p>看一个最近的出块实例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Height     : 564,270</span><br><span class=\"line\">Block Hash : 0000000000000000000674a05c77c2911ad42c94bc4170ac90f0c89ca8c92734</span><br></pre></td></tr></table></figure></p>\n<p>前20个都是零，另外后面的数也要小于一定的数，那么才满足条件。而这些哈希值结果是随机的，能做的这么规律，只能是不断地更换原文内容不断地进行尝试，在大量的随机结果中来筛选满足出块条件的。难度并非固定的，根据全网算力挖块的情况，每挖出来2016个区块（约两周时间2016/6/24=14days）就调整一次难度。若挖完2016区块所用的时间短于两周，那就提高难度；而若长于两周，那就降低难度。</p>\n<h5 id=\"3-2原始数据有什么内容？\"><a href=\"#3-2原始数据有什么内容？\" class=\"headerlink\" title=\"3.2原始数据有什么内容？\"></a>3.2原始数据有什么内容？</h5><p>并非对整个区块内容取Hash值，而是仅仅只对80字节大小的区块头，进行SHA256算法。这80字节具体分为六个部分。</p>\n<p><img src=\"https://i.loli.net/2019/02/24/5c7185669900c.png\" alt=\"image\"></p>\n<p>1)版本号Version：4字节，进行投票时变动</p>\n<p>按目前的BIP9升级规范，版本号是用于投票区块自己支持的分叉升级方案，如若支持SW可版本号为0x20000002具体可看下面这个文章：</p>\n<p><a href=\"https://www.8btc.com/article/359000\" target=\"_blank\" rel=\"noopener\">谈谈软分叉升级规范BIP8-后矿工时代的软分叉方式</a></p>\n<p>2)上一个区块Hash：32字节，有新区块时变动</p>\n<p>这是将区块串成区块链的关键，表示这个区块是在哪个区块的基础之上进行挖矿而挖到的。当比特全网出现合法的新区块后，要及时替换上新区块的Hash，否则就算挖出来也可能被孤立。</p>\n<p>3)交易树根MerkleRoot：32字节，交易变时变动</p>\n<p>本应该是所有交易都进行Hash的，但是计算量太大，于是将所有交易用Merkle Root Hash的方法，将所有交易Hash合并成一个32字节的Hash数据。它能代表所有交易，任何交易的任何细小变动都会引起MerkleRoot的变动。这个后面还有更多讨论和图。</p>\n<p>4)时间戳TimeStamp：4字节，当前时间变动</p>\n<p>最好写当前时间，但不是很严格，允许有一定的时间偏差，但不能偏差太大，偏差太大会被区块孤立的。因为不严格，有时下个区块比它的上个区块的时间戳时间还早，这是有可能的，但真实的诞生时间当然是先有上个区块，才会有下个区块。</p>\n<p>5)当前难度值Bits：4字节，每两周左右变一次</p>\n<p>由全网算力决定，每2016个区块重新调整，调整算法固定，就是说在调整时，大家都可以根据历史数据自己计算出来，而不是由谁指定。怎么用四个字节表示难度呢？有点类似于天文数字的科学计数法，第一个字节V1代表右移的位数，用剩下三字节V3表示具体的有效数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">F(nBits)=V3 * 2^(8*(V1-3) )</span><br></pre></td></tr></table></figure></p>\n<p>6)随机数Nonce：4字节，随时可变</p>\n<p>这个是给矿工挖矿时自己调整用的，以便能找到合适的值让区块头的Hash结果能满足难度需求。这个参数估计中本聪有点失误，设计小了，仅仅4字节，CPU挖矿时代够用，但显卡GPU时代，就有点不够用了，几秒的时间就能全部的Nonce都全试了一次了。不过可以微调上面的时间戳TimeStamp，调一次就可以再挖几秒，勉强够用。然而进入专业矿机矿池时代，Nonce就远远不够用了，由于各字段一般都有较明确有固定含义不能轻易动，于是转向32字节的交易树根MerkleRoot。</p>\n<h5 id=\"3-3矿池为矿工提供的挖矿服务\"><a href=\"#3-3矿池为矿工提供的挖矿服务\" class=\"headerlink\" title=\"3.3矿池为矿工提供的挖矿服务\"></a>3.3矿池为矿工提供的挖矿服务</h5><p>收集比特交易是矿池上完成的，矿池需要运行全节点，而矿工却不需要。如下图蓝线指示，矿池会由待打包的交易生成那些黑点，然后时常发给矿工。另外构造一个基本coinbase交易，也发给矿工。理论上矿池给矿工的coinbase交易内容能维持较长时间不变动。但SW隔离严证实施后，每当有交易顺序或交易内容调整时，都需要变动coinbase。还有就是矿池要提供除了MerklerRoot和Nonce之外的区块头数据。</p>\n<h5 id=\"3-4矿工需要做什么？\"><a href=\"#3-4矿工需要做什么？\" class=\"headerlink\" title=\"3.4矿工需要做什么？\"></a>3.4矿工需要做什么？</h5><p>矿工收到从矿池发过来的信息后:</p>\n<p>第一步是计算红点，完善coinbase交易一般是加个随机数即可完善好，然后对coinbase交易进行SHA256的Hash计算。</p>\n<p>第二步是计算绿点，将coinbase的结果，再依次和下图中的黑点逐一合并得出上一层的Hash，最终得到最上面的交易树根MerklerRoot。</p>\n<p>第三步是计算区块头Hash，有了MerklerRoot后，结合矿池提供的区块头数据，再加个随机变动的Nonce就可以形成完整区块头，用其计算Hash。当Nonce完全遍历一遍和足够变动时间戳后，正常一般是回到第一步更换一个随机数来重新完善coinbase交易，进而第二步中MerklerRoot值最终将不一样。而ASICBoost可能是调换交易顺序而更新MerklerRoot。</p>\n<p>第四步是提交成功的Share计算结果，并非要满足全网的难度般，只要满足矿池设的挖矿难度就可以提交了，一般提交给矿池自己的矿工ID和任务ID，coinbase的随机数和区块头的时间戳TimeStamp及随机数Nonce。</p>\n<p>矿池在收到后及时进行验证，若满足则记一份功劳贡献，同时看看是否满足全网的难度要求，若满足则广播发布出去，从而挖到新块，且按记录的功劳Share数量分配给各矿工应有的币量。</p>\n<p><img src=\"https://i.loli.net/2019/02/24/5c718567c4a75.png\" alt=\"image\"></p>\n<h3 id=\"4-Asicboost优化\"><a href=\"#4-Asicboost优化\" class=\"headerlink\" title=\"4.Asicboost优化\"></a>4.Asicboost优化</h3><p>根据目前了解，简单说，其就是利用了SHA256算法的内部计算规则，先64字节一组，然后再4个字节一个组。而ASICBoost专利，应该就是用交换交易位置的方式，不必修改coinbase，来快速得到很多相同的末尾4字节的MerklerRoot，从而硬件可加速优化计算区块头两次SHA256的哈希值，即SHA256( SHA256( BlockHeader ))的速度。</p>\n<p><img src=\"https://i.loli.net/2019/02/24/5c718567c54d9.png\" alt=\"image\"></p>\n<p>在计算这个区块头的SHA256时，我们需要先用固定的填充位补齐为128字节，之后SHA256会64字节一组去处理，可以简单认为是 F ( F（SHA256规范的初始值，前半部分）, 后半部分）。F又需要对这64字节先按4字节一组拆分，进行64轮计算。结合上图，我们不难发现，Merkle Root的前28个字节和后4个字节被分开了，在修改Nonce过程中，前半部分是不变的，而后半部分的前12个字节也是不变的。因此目前几乎所有的芯片都已经做了这两个优化，即前半部分的处理结果（getwork中的midstate）和后半部分的前3轮结果（midstate3）。<strong>这样的优化效果是 (61/64+1)/3 = 65.1%，提升了34.9%。</strong></p>\n<p>Merkle Root在图上显得很尴尬，如果中本聪设计的时候Version变成第三个字段该多好（就是说把Version放在MerkleRoot的后面）。这样后半段的前4个字节就固定了，如果我们对于时间戳要求不那么高，前12个字节可以完全固定下来了。对于芯片来说可以节省更多的计算，也可以去掉对应的一些电路。ASICBoost将这个脑洞往实践推了一步：我们去构建一组后4个字节相同的Merkle Root。</p>\n<p>这样问题就变成能不能高效找到后缀一样的Merkle Root？效率提升有多大？ASICBoost的白皮书提到有很高效的方法，并且给出了一张表：</p>\n<p><img src=\"https://i.loli.net/2019/02/24/5c718566f39bf.png\" alt=\"image\"></p>\n<p>ASICBoost白皮书的Merkle Root碰撞数量对效率影响ASICBoost白皮书的Merkle Root碰撞数量对效率影响。（表格的意思是若找到五个相同后4字节的Merkle Root那么效率能提升20%）<br>这里问题的本质是一个32位的哈希碰撞，根据“生日悖论”，找到一组碰撞需要的尝试次数其实并不多，我们只需要77000次就有50%概率找到两个后缀相同的Merkle Root。当然对于一台矿机来说，仅仅2个是远远不够的，如果是矿场的话应该需要配备专门的硬件去产生足够的任务。尝试新的Merkle Root通常有两种方法：</p>\n<p>方法一：修改Coinbase交易。这个方法似乎最简单而且隐蔽，但是白皮书认为不够高效；</p>\n<p>方法二：交换任意交易的顺序。白皮书只举例了方法2，其他方法并未给出。注意无论是1和2，新的Merkle Root并不需要从下而上全部计算。</p>\n<h4 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h4><p>看到这里，你大概就了解了什么是AsicBoost, 是简化了比特币挖矿SHA256的计算量，来提高效率的。<br>关于Asicboost在专利争议上还有一段故事，你可以搜索阅读下Asicboost 专利的爱恨情仇。</p>\n","categories":[],"tags":[]},{"title":"about","url":"http://orangem.io/about/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://orangem.io/search/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://orangem.io/project/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://orangem.io/category/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://orangem.io/tag/index.html","content":"","categories":[],"tags":[]}]